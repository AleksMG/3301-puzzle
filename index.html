<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Гомофонический Шифр</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Fira Code', 'Cascadia Code', monospace;
        }
        
        body {
            background: linear-gradient(135deg, #0a192f, #112240, #0a192f);
            color: #64ffda;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(23, 42, 69, 0.8);
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid #64ffda;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            color: #64ffda;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
        }
        
        .subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            color: #8892b0;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: rgba(23, 42, 69, 0.8);
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid #1e2d3d;
        }
        
        .panel-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #64ffda;
            border-bottom: 2px solid #64ffda;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .panel-title::before {
            content: "> ";
            color: #ff79c6;
            margin-right: 10px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #50fa7b;
            font-size: 1.1rem;
        }
        
        input, textarea, button {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 6px;
            background: rgba(30, 45, 61, 0.8);
            color: #f8f8f2;
            font-size: 1.1rem;
            font-family: 'Fira Code', monospace;
            border: 1px solid #44475a;
        }
        
        textarea {
            height: 120px;
            resize: vertical;
        }
        
        input:focus, textarea:focus {
            outline: none;
            border-color: #6272a4;
            box-shadow: 0 0 0 2px rgba(98, 114, 164, 0.3);
        }
        
        button {
            background: linear-gradient(135deg, #50fa7b, #64ffda);
            color: #0a192f;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
            border: none;
            font-size: 1.2rem;
            padding: 16px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .visualization {
            height: 450px;
            position: relative;
            overflow: hidden;
            border-radius: 10px;
            background: #0a192f;
            border: 1px solid #64ffda;
            margin-bottom: 30px;
        }
        
        #cube-container {
            width: 100%;
            height: 100%;
        }
        
        .result {
            margin-top: 20px;
            padding: 20px;
            background: rgba(30, 45, 61, 0.8);
            border-radius: 8px;
            font-family: 'Fira Code', monospace;
            word-break: break-all;
            border: 1px solid #44475a;
            color: #f8f8f2;
            font-size: 1.1rem;
            line-height: 1.8;
        }
        
        .math-section {
            margin-top: 40px;
            background: rgba(23, 42, 69, 0.8);
            border-radius: 10px;
            padding: 30px;
            border: 1px solid #1e2d3d;
        }
        
        .math-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #64ffda;
            border-bottom: 2px solid #64ffda;
            padding-bottom: 10px;
        }
        
        .formula {
            background: rgba(30, 45, 61, 0.8);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Fira Code', monospace;
            overflow-x: auto;
            border: 1px solid #44475a;
            color: #f8f8f2;
        }
        
        .algorithm {
            background: rgba(30, 45, 61, 0.8);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #44475a;
        }
        
        .algorithm ol {
            padding-left: 30px;
        }
        
        .algorithm li {
            margin-bottom: 15px;
            color: #f8f8f2;
            font-size: 1.1rem;
        }
        
        .algorithm h3 {
            color: #ff79c6;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }
        
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .stat-box {
            background: rgba(30, 45, 61, 0.8);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            border: 1px solid #44475a;
        }
        
        .stat-value {
            font-size: 2.2rem;
            font-weight: bold;
            color: #ff79c6;
            margin-bottom: 8px;
        }
        
        .stat-label {
            font-size: 1.1rem;
            color: #50fa7b;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 30px;
            opacity: 0.7;
            font-size: 1rem;
            color: #6272a4;
        }
        
        .byte-value {
            color: #ff79c6;
            font-weight: bold;
        }
        
        .coordinate {
            color: #50fa7b;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>3D Гомофонический Шифр</h1>
            <p class="subtitle">Куб 16×16×16 | Омофоны 0001-4096 | Профессиональная реализация</p>
        </header>
        
        <div class="main-content">
            <div class="panel">
                <h2 class="panel-title">Шифрование</h2>
                
                <div class="input-group">
                    <label for="plainText">Исходные данные (байты):</label>
                    <textarea id="plainText" placeholder="Введите данные для шифрования">48656C6C6F20576F726C64</textarea>
                </div>
                
                <div class="input-group">
                    <label for="key">Ключ шифрования (hex):</label>
                    <input type="text" id="key" value="4F6D6E6950686F6E65313233" placeholder="Введите ключ в hex-формате">
                </div>
                
                <button id="encryptBtn">Зашифровать</button>
                
                <div class="input-group">
                    <label>Зашифрованные данные (омофоны):</label>
                    <div class="result" id="cipherResult">Результат появится здесь</div>
                </div>
            </div>
            
            <div class="panel">
                <h2 class="panel-title">Дешифрование</h2>
                
                <div class="input-group">
                    <label for="cipherText">Зашифрованные данные (омофоны):</label>
                    <textarea id="cipherText" placeholder="Введите омофоны для дешифрования"></textarea>
                </div>
                
                <div class="input-group">
                    <label for="decryptKey">Ключ дешифрования (hex):</label>
                    <input type="text" id="decryptKey" value="4F6D6E6950686F6E65313233" placeholder="Введите ключ в hex-формате">
                </div>
                
                <button id="decryptBtn">Дешифровать</button>
                
                <div class="input-group">
                    <label>Дешифрованные данные (байты):</label>
                    <div class="result" id="decryptResult">Результат появится здесь</div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2 class="panel-title">3D Визуализация Куб 16×16×16</h2>
            <div class="visualization">
                <div id="cube-container"></div>
            </div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="pointCount">0</div>
                    <div class="stat-label">Всего точек в кубе</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="byteCount">0</div>
                    <div class="stat-label">Байтов обработано</div>
                </div>
            </div>
        </div>
        
        <div class="math-section">
            <h2 class="math-title">Математическая основа алгоритма</h2>
            
            <div class="algorithm">
                <h3>Алгоритм шифрования:</h3>
                <ol>
                    <li>Преобразовать входные данные в последовательность байтов</li>
                    <li>Для каждого байта B определить 16 омофонов в кубе:
                        <div class="formula">H = { (x, y, z) | x, y, z ∈ [0,15], f(B, x, y, z) = 0 }</div>
                    </li>
                    <li>Используя ключ K, выбрать один омофон из H:
                        <div class="formula">index = (B + K[i mod len(K)]) mod 16</div>
                    </li>
                    <li>Преобразовать выбранную точку (x,y,z) в значение омофона:
                        <div class="formula">O = x × 256 + y × 16 + z + 1</div>
                    </li>
                </ol>
            </div>
            
            <div class="algorithm">
                <h3>Алгоритм дешифрования:</h3>
                <ol>
                    <li>Для каждого омофона O вычислить координаты точки:
                        <div class="formula">O' = O - 1; x = O' ÷ 256; y = (O' mod 256) ÷ 16; z = O' mod 16</div>
                    </li>
                    <li>Используя ключ K, восстановить исходный байт:
                        <div class="formula">B = (f⁻¹(x, y, z) - K[i mod len(K)] + 256) mod 256</div>
                    </li>
                </ol>
            </div>
            
            <div class="formula">
                <h3>Формула преобразования байта в координаты:</h3>
                <p>Для байта B и индекса i ∈ [0,15]:</p>
                <p>x = (B + i) mod 16</p>
                <p>y = (B × 7 + i × 11) mod 16</p>
                <p>z = (B × 13 + i × 17) mod 16</p>
            </div>
            
            <div class="formula">
                <h3>Формула восстановления байта из координат:</h3>
                <p>Для координат (x, y, z):</p>
                <p>B = (x - i + 16) mod 16, где i ∈ [0,15] определяется из y и z</p>
            </div>
        </div>
        
        <footer>
            <p>3D Гомофонический Шифр | Профессиональная реализация | Куб 16×16×16 | Омофоны 0001-4096</p>
        </footer>
    </div>

    <script>
        // Реализация 3D гомофонического шифра
        class HomophonicCipher3D {
            constructor() {
                this.cubeSize = 16;
                this.totalPoints = this.cubeSize * this.cubeSize * this.cubeSize;
                this.homophoneMap = new Map();
                this.reverseMap = new Map();
                this.initMappings();
            }
            
            // Инициализация преобразований байт ↔ омофоны
            initMappings() {
                // Создаем отображение для каждого байта (0-255) на 16 омофонов
                for (let byte = 0; byte < 256; byte++) {
                    const homophones = [];
                    
                    // Генерируем 16 омофонов для каждого байта
                    for (let i = 0; i < 16; i++) {
                        const x = (byte + i) % this.cubeSize;
                        const y = (byte * 7 + i * 11) % this.cubeSize;
                        const z = (byte * 13 + i * 17) % this.cubeSize;
                        
                        // Преобразуем координаты в значение омофона (1-4096)
                        const homophone = x * 256 + y * 16 + z + 1;
                        homophones.push(homophone);
                        
                        // Сохраняем обратное отображение
                        this.reverseMap.set(homophone, { byte, index: i });
                    }
                    
                    this.homophoneMap.set(byte, homophones);
                }
            }
            
            // Шифрование массива байтов
            encryptBytes(bytes, keyBytes) {
                const result = [];
                let keyIndex = 0;
                
                for (let byte of bytes) {
                    // Получаем омофоны для этого байта
                    const homophones = this.homophoneMap.get(byte);
                    
                    // Выбираем омофон на основе ключа
                    const keyByte = keyBytes[keyIndex % keyBytes.length];
                    const homophoneIndex = (byte + keyByte) % homophones.length;
                    const selectedHomophone = homophones[homophoneIndex];
                    
                    result.push(selectedHomophone);
                    keyIndex++;
                }
                
                return result;
            }
            
            // Дешифрование массива омофонов
            decryptHomophones(homophones, keyBytes) {
                const result = [];
                let keyIndex = 0;
                
                for (let homophone of homophones) {
                    // Получаем байт и индекс из омофона
                    const { byte, index } = this.reverseMap.get(homophone);
                    
                    // Проверяем ключ
                    const keyByte = keyBytes[keyIndex % keyBytes.length];
                    const expectedIndex = (byte + keyByte) % 16;
                    
                    if (index === expectedIndex) {
                        result.push(byte);
                    } else {
                        throw new Error(`Ошибка проверки ключа для омофона ${homophone}`);
                    }
                    
                    keyIndex++;
                }
                
                return result;
            }
            
            // Преобразование hex-строки в массив байтов
            hexToBytes(hex) {
                const bytes = [];
                for (let i = 0; i < hex.length; i += 2) {
                    bytes.push(parseInt(hex.substr(i, 2), 16));
                }
                return bytes;
            }
            
            // Преобразование массива байтов в hex-строку
            bytesToHex(bytes) {
                return bytes.map(b => b.toString(16).padStart(2, '0')).join('');
            }
            
            // Получение всех точек для визуализации
            getAllPoints() {
                const points = [];
                for (let x = 0; x < this.cubeSize; x++) {
                    for (let y = 0; y < this.cubeSize; y++) {
                        for (let z = 0; z < this.cubeSize; z++) {
                            points.push({x, y, z});
                        }
                    }
                }
                return points;
            }
            
            // Получение точек для конкретного байта
            getPointsForByte(byte) {
                const points = [];
                const homophones = this.homophoneMap.get(byte) || [];
                
                for (let homophone of homophones) {
                    const val = homophone - 1;
                    const x = Math.floor(val / 256);
                    const y = Math.floor((val % 256) / 16);
                    const z = val % 16;
                    points.push({x, y, z});
                }
                
                return points;
            }
        }

        // 3D визуализация
        class CubeVisualization {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.container.appendChild(this.renderer.domElement);
                
                this.points = [];
                this.pointGroup = new THREE.Group();
                this.scene.add(this.pointGroup);
                
                // Добавляем освещение
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);
                
                // Добавляем каркас куба
                const geometry = new THREE.BoxGeometry(16, 16, 16);
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x64ffda }));
                this.scene.add(line);
                
                // Позиционируем камеру
                this.camera.position.z = 30;
                this.camera.position.y = 15;
                this.camera.lookAt(0, 0, 0);
                
                // Добавляем оси
                this.addAxes();
                
                // Обработка изменения размера окна
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Запускаем анимацию
                this.animate();
            }
            
            addAxes() {
                // Ось X (красная)
                const xGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-8, 0, 0),
                    new THREE.Vector3(8, 0, 0)
                ]);
                const xMaterial = new THREE.LineBasicMaterial({ color: 0xff5555 });
                const xAxis = new THREE.Line(xGeometry, xMaterial);
                this.scene.add(xAxis);
                
                // Ось Y (зеленая)
                const yGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, -8, 0),
                    new THREE.Vector3(0, 8, 0)
                ]);
                const yMaterial = new THREE.LineBasicMaterial({ color: 0x55ff55 });
                const yAxis = new THREE.Line(yGeometry, yMaterial);
                this.scene.add(yAxis);
                
                // Ось Z (синяя)
                const zGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, -8),
                    new THREE.Vector3(0, 0, 8)
                ]);
                const zMaterial = new THREE.LineBasicMaterial({ color: 0x5555ff });
                const zAxis = new THREE.Line(zGeometry, zMaterial);
                this.scene.add(zAxis);
            }
            
            addPoints(points, color = 0x64ffda) {
                // Очищаем существующие точки
                this.pointGroup.clear();
                
                // Добавляем новые точки
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                for (const point of points) {
                    // Преобразуем из диапазона [0,15] в [-8,7] для центрирования
                    positions.push(point.x - 8, point.y - 8, point.z - 8);
                    
                    // Добавляем вариацию цвета на основе позиции
                    colors.push(
                        (point.x / 16) * 0.8 + 0.2,
                        (point.y / 16) * 0.8 + 0.2,
                        (point.z / 16) * 0.8 + 0.2
                    );
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.7,
                    vertexColors: true,
                    sizeAttenuation: false
                });
                
                const pointCloud = new THREE.Points(geometry, material);
                this.pointGroup.add(pointCloud);
                
                // Обновляем статистику
                document.getElementById('pointCount').textContent = points.length;
            }
            
            onWindowResize() {
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Вращаем группу точек
                this.pointGroup.rotation.x += 0.005;
                this.pointGroup.rotation.y += 0.007;
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Инициализация приложения
        document.addEventListener('DOMContentLoaded', () => {
            const cipher = new HomophonicCipher3D();
            const visualization = new CubeVisualization('cube-container');
            
            // Показываем все точки при запуске
            visualization.addPoints(cipher.getAllPoints());
            
            // Настройка обработчиков событий
            document.getElementById('encryptBtn').addEventListener('click', () => {
                const text = document.getElementById('plainText').value;
                const key = document.getElementById('key').value;
                
                if (text && key) {
                    try {
                        const bytes = cipher.hexToBytes(text);
                        const keyBytes = cipher.hexToBytes(key);
                        
                        const homophones = cipher.encryptBytes(bytes, keyBytes);
                        document.getElementById('cipherResult').textContent = homophones.map(h => h.toString(16).padStart(4, '0')).join(' ');
                        
                        // Визуализируем точки для первого байта
                        if (bytes.length > 0) {
                            const points = cipher.getPointsForByte(bytes[0]);
                            visualization.addPoints(points);
                        }
                        
                        document.getElementById('byteCount').textContent = bytes.length;
                    } catch (e) {
                        document.getElementById('cipherResult').textContent = 'Ошибка: ' + e.message;
                    }
                }
            });
            
            document.getElementById('decryptBtn').addEventListener('click', () => {
                const text = document.getElementById('cipherText').value;
                const key = document.getElementById('decryptKey').value;
                
                if (text && key) {
                    try {
                        const homophones = text.split(' ').map(h => parseInt(h, 16));
                        const keyBytes = cipher.hexToBytes(key);
                        
                        const bytes = cipher.decryptHomophones(homophones, keyBytes);
                        document.getElementById('decryptResult').textContent = cipher.bytesToHex(bytes);
                    } catch (e) {
                        document.getElementById('decryptResult').textContent = 'Ошибка: ' + e.message;
                    }
                }
            });
        });
    </script>
</body>
</html>
