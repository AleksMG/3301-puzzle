<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeonHomophone Cipher | Professional Edition</title>
    <style>
        :root {
            --background: #0a0a12;
            --surface: #16162a;
            --surface-alt: #1c1c34;
            --primary: #8a2be2;
            --primary-light: #9370db;
            --accent: #00bfff;
            --accent-alt: #00ced1;
            --text: #e6e6fa;
            --text-dim: #a0a0c0;
            --success: #00fa9a;
            --warning: #ffd700;
            --error: #ff6b6b;
            --terminal: #0f0f1f;
            --terminal-border: #2a2a55;
            --glow: 0 0 10px var(--accent);
            --transition: all 0.3s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            font-family: 'Fira Code', 'Cascadia Code', monospace;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: 24px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 30px;
            background: var(--surface);
            border-radius: 16px;
            border: 1px solid var(--primary);
            box-shadow: var(--glow);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent,
                rgba(138, 43, 226, 0.1),
                rgba(0, 191, 255, 0.1),
                transparent
            );
            transform: rotate(45deg);
            animation: shimmer 10s infinite linear;
            pointer-events: none;
        }

        @keyframes shimmer {
            0% { transform: rotate(45deg) translateX(-50%); }
            100% { transform: rotate(45deg) translateX(50%); }
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 12px;
            background: linear-gradient(45deg, var(--accent), var(--primary-light));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 15px rgba(0, 191, 255, 0.5);
            letter-spacing: 1px;
            position: relative;
            z-index: 1;
        }

        .header-desc {
            color: var(--text-dim);
            font-size: 1.1rem;
            max-width: 700px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .grid-system {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 24px;
        }

        .card {
            background: var(--surface);
            padding: 28px;
            border-radius: 16px;
            border: 1px solid var(--primary);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.2);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            opacity: 0.7;
            transition: var(--transition);
        }

        .card:hover {
            box-shadow: 0 0 25px rgba(138, 43, 226, 0.3);
            transform: translateY(-5px);
        }

        .card:hover::after {
            opacity: 1;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 22px;
            color: var(--accent);
            padding-bottom: 12px;
            border-bottom: 2px solid var(--primary);
            display: flex;
            align-items: center;
        }

        h2::before {
            content: "> ";
            color: var(--accent-alt);
        }

        .input-group {
            margin-bottom: 20px;
            position: relative;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--text-dim);
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input, textarea, button, select {
            width: 100%;
            padding: 14px 18px;
            border: none;
            border-radius: 10px;
            background: var(--surface-alt);
            color: var(--text);
            font-size: 1rem;
            border: 1px solid var(--primary);
            transition: var(--transition);
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 15px rgba(0, 191, 255, 0.3);
        }

        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: 'Fira Code', monospace;
        }

        button {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: white;
            font-weight: 600;
            cursor: pointer;
            border: none;
            margin-top: 15px;
            transition: var(--transition);
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-size: 0.9rem;
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
            z-index: -1;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 191, 255, 0.4);
        }

        .switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 12px;
            background: var(--surface-alt);
            border-radius: 10px;
            border: 1px solid var(--primary);
        }

        .switch label {
            margin-bottom: 0;
        }

        .switch input[type="checkbox"] {
            width: auto;
            transform: scale(1.5);
        }

        .result {
            margin-top: 20px;
            padding: 20px;
            background: var(--terminal);
            border-radius: 10px;
            min-height: 80px;
            font-family: 'Fira Code', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            border: 1px solid var(--terminal-border);
            overflow-x: auto;
        }

        .status {
            padding: 12px;
            border-radius: 10px;
            margin-top: 15px;
            font-weight: 600;
            border: 1px solid;
        }

        .status.success {
            background: rgba(0, 250, 154, 0.1);
            color: var(--success);
            border-color: var(--success);
        }

        .status.error {
            background: rgba(255, 107, 107, 0.1);
            color: var(--error);
            border-color: var(--error);
        }

        .stats {
            font-size: 0.9rem;
            color: var(--text-dim);
            line-height: 1.6;
            margin-top: 15px;
            padding: 15px;
            background: var(--surface-alt);
            border-radius: 10px;
            border: 1px solid var(--primary);
        }
        
        .progress {
            height: 8px;
            background: var(--surface-alt);
            border-radius: 4px;
            margin-top: 15px;
            overflow: hidden;
            border: 1px solid var(--primary);
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            width: 0%;
            transition: width 0.5s ease;
        }

        .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        @media (max-width: 1100px) {
            .config-grid {
                grid-template-columns: 1fr;
            }
            
            .grid-system {
                grid-template-columns: 1fr;
            }
        }

        .terminal-style {
            background: var(--terminal);
            border: 1px solid var(--terminal-border);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .terminal-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--terminal-border);
        }

        .terminal-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .terminal-red {
            background: var(--error);
        }

        .terminal-yellow {
            background: var(--warning);
        }

        .terminal-green {
            background: var(--success);
        }

        .key-value {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .key {
            color: var(--text-dim);
        }

        .value {
            color: var(--accent);
            font-weight: 600;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted var(--text-dim);
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: var(--surface-alt);
            color: var(--text);
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            border: 1px solid var(--primary);
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            background: var(--surface);
            color: var(--text);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transform: translateX(150%);
            transition: transform 0.3s ease;
            z-index: 1000;
            border-left: 4px solid var(--primary);
        }

        .notification.show {
            transform: translateX(0);
        }

        .char-counter {
            text-align: right;
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-top: 5px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>NEONHOMOPHONE CIPHER</h1>
            <p class="header-desc">Advanced homophonic substitution cipher with PBKDF2 key derivation and non-deterministic encryption</p>
        </header>

        <div class="config-grid">
            <div class="card">
                <h2>CONFIGURATION</h2>
                
                <div class="switch">
                    <label for="cbc-mode" class="tooltip">CBC Mode
                        <span class="tooltiptext">Cipher Block Chaining adds diffusion by chaining cipher blocks</span>
                    </label>
                    <input type="checkbox" id="cbc-mode" checked>
                </div>

                <div class="switch">
                    <label for="affine-mode" class="tooltip">Affine Transformation
                        <span class="tooltiptext">Applies mathematical transformation to each character</span>
                    </label>
                    <input type="checkbox" id="affine-mode" checked>
                </div>

                <div class="input-group">
                    <label for="affine-a" class="tooltip">Affine Parameter A
                        <span class="tooltiptext">Must be coprime with 26 (alphabet size)</span>
                    </label>
                    <input type="number" id="affine-a" min="1" max="25" value="5">
                </div>

                <div class="input-group">
                    <label for="affine-b" class="tooltip">Affine Parameter B
                        <span class="tooltiptext">Shift value for the affine transformation</span>
                    </label>
                    <input type="number" id="affine-b" min="0" max="25" value="9">
                </div>
            </div>

            <div class="card">
                <h2>CRYPTOGRAPHIC KEY</h2>
                
                <div class="input-group">
                    <label for="crypto-key">Password</label>
                    <input type="password" id="crypto-key" value="MILITARY_GRADE_KEY_2024">
                    <div class="char-counter"><span id="key-length">0</span> characters</div>
                </div>
                
                <div class="input-group">
                    <label for="key-iterations" class="tooltip">PBKDF2 Iterations
                        <span class="tooltiptext">Higher values increase security but slow down processing</span>
                    </label>
                    <input type="number" id="key-iterations" min="100000" max="1000000" value="600000">
                </div>

                <button id="generate-btn">
                    <span class="loading" id="generate-loading" style="display: none;"></span>
                    GENERATE HOMOPHONE TABLE
                </button>
                
                <div class="progress">
                    <div class="progress-bar" id="key-progress"></div>
                </div>
                
                <div id="status" class="status success">System Ready</div>

                <div class="terminal-style">
                    <div class="terminal-header">
                        <div class="terminal-dot terminal-red"></div>
                        <div class="terminal-dot terminal-yellow"></div>
                        <div class="terminal-dot terminal-green"></div>
                        <span style="margin-left: 10px;">key_info.term</span>
                    </div>
                    <div class="key-value">
                        <span class="key">Key derivation:</span>
                        <span class="value">PBKDF2-SHA512</span>
                    </div>
                    <div class="key-value">
                        <span class="key">Homophones:</span>
                        <span class="value">99,999</span>
                    </div>
                    <div class="key-value">
                        <span class="key">Security level:</span>
                        <span class="value" id="security-level">256-bit</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="grid-system">
            <div class="card">
                <h2>ENCRYPTION</h2>
                
                <div class="input-group">
                    <label for="plaintext">Plaintext</label>
                    <textarea id="plaintext" placeholder="Enter text to encrypt">TOP SECRET MESSAGE</textarea>
                    <div class="char-counter"><span id="plaintext-length">0</span> characters</div>
                </div>

                <button id="encrypt-btn">
                    <span class="loading" id="encrypt-loading" style="display: none;"></span>
                    ENCRYPT
                </button>

                <div class="input-group">
                    <label>Ciphertext</label>
                    <div class="result" id="encryption-result"></div>
                    <div class="char-counter"><span id="ciphertext-length">0</span> homophones</div>
                </div>
            </div>

            <div class="card">
                <h2>DECRYPTION</h2>
                
                <div class="input-group">
                    <label for="ciphertext">Ciphertext</label>
                    <textarea id="ciphertext" placeholder="Enter homophones to decrypt (5-digit numbers separated by spaces)"></textarea>
                    <div class="char-counter"><span id="ciphertext-input-length">0</span> homophones</div>
                </div>

                <button id="decrypt-btn">
                    <span class="loading" id="decrypt-loading" style="display: none;"></span>
                    DECRYPT
                </button>

                <div class="input-group">
                    <label>Decrypted Text</label>
                    <div class="result" id="decryption-result"></div>
                    <div class="char-counter"><span id="decrypted-length">0</span> characters</div>
                </div>
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        // Constants
        const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const ALPHABET_SIZE = 26;
        const TOTAL_HOMOPHONES = 99999;
        const HOMOPHONE_LENGTH = 5;
        const SALT = new Uint8Array([104, 111, 109, 111, 112, 104, 111, 110, 101, 95, 115, 97, 108, 116, 95, 50]); // "homophone_salt_2"

        // Global state
        let homophoneTable = {};
        let reverseHomophoneTable = {};
        let derivedKey = null;
        let config = {
            cbcMode: true,
            affineMode: true,
            affineA: 5,
            affineB: 9
        };

        // DOM Elements cache
        const elements = {
            cbcMode: document.getElementById('cbc-mode'),
            affineMode: document.getElementById('affine-mode'),
            affineA: document.getElementById('affine-a'),
            affineB: document.getElementById('affine-b'),
            cryptoKey: document.getElementById('crypto-key'),
            keyIterations: document.getElementById('key-iterations'),
            generateBtn: document.getElementById('generate-btn'),
            keyProgress: document.getElementById('key-progress'),
            status: document.getElementById('status'),
            plaintext: document.getElementById('plaintext'),
            ciphertext: document.getElementById('ciphertext'),
            encryptBtn: document.getElementById('encrypt-btn'),
            decryptBtn: document.getElementById('decrypt-btn'),
            encryptionResult: document.getElementById('encryption-result'),
            decryptionResult: document.getElementById('decryption-result'),
            securityLevel: document.getElementById('security-level'),
            notification: document.getElementById('notification'),
            // Loading indicators
            generateLoading: document.getElementById('generate-loading'),
            encryptLoading: document.getElementById('encrypt-loading'),
            decryptLoading: document.getElementById('decrypt-loading'),
            // Character counters
            keyLength: document.getElementById('key-length'),
            plaintextLength: document.getElementById('plaintext-length'),
            ciphertextLength: document.getElementById('ciphertext-length'),
            ciphertextInputLength: document.getElementById('ciphertext-input-length'),
            decryptedLength: document.getElementById('decrypted-length')
        };

        // Utility functions
        const utils = {
            showNotification: (message, type = 'info') => {
                elements.notification.textContent = message;
                elements.notification.style.borderLeftColor = 
                    type === 'error' ? 'var(--error)' : 
                    type === 'success' ? 'var(--success)' : 'var(--primary)';
                elements.notification.classList.add('show');
                
                setTimeout(() => {
                    elements.notification.classList.remove('show');
                }, 3000);
            },
            
            setLoading: (button, isLoading) => {
                const loadingElement = elements[`${button}Loading`];
                if (loadingElement) {
                    loadingElement.style.display = isLoading ? 'inline-block' : 'none';
                }
                
                elements[`${button}Btn`].disabled = isLoading;
            },
            
            updateCharCounter: (element, counterElement) => {
                const length = element.value.length;
                elements[counterElement].textContent = length;
                return length;
            },
            
            validateAffineParam: (a) => {
                return utils.gcd(a, ALPHABET_SIZE) === 1;
            },
            
            gcd: (a, b) => {
                if (b === 0) return a;
                return utils.gcd(b, a % b);
            },
            
            // Modular inverse for affine cipher
            modInverse: (a, m) => {
                a = (a % m + m) % m;
                for (let x = 1; x < m; x++) {
                    if ((a * x) % m === 1) return x;
                }
                return 1;
            }
        };

        // Homophone Cipher Class
        class HomophoneCipher {
            constructor() {
                this.initializeTables();
            }
            
            initializeTables() {
                homophoneTable = {};
                reverseHomophoneTable = {};
                
                // Initialize empty arrays for each letter
                for (let char of ALPHABET) {
                    homophoneTable[char] = [];
                }
            }
            
            // Derive key using PBKDF2 with SHA-512
            async deriveKey(password, iterations) {
                const encoder = new TextEncoder();
                const passwordBuffer = encoder.encode(password);
                
                // Import the password as a key
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    passwordBuffer,
                    'PBKDF2',
                    false,
                    ['deriveBits']
                );
                
                // Derive key using PBKDF2
                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: SALT,
                        iterations: iterations,
                        hash: 'SHA-512'
                    },
                    keyMaterial,
                    512 // 512 bits
                );
                
                return new Uint8Array(derivedBits);
            }
            
            // Простой детерминированный PRNG на основе HMAC
            createPRNG(seed) {
                const seedArray = new Uint32Array(seed.buffer);
                let state = seedArray[0];
                
                return function() {
                    state = (state * 1664525 + 1013904223) >>> 0;
                    return state / 4294967296; // возвращает число от 0 до 1
                };
            }
            
            // Оптимизированное детерминистическое перемешивание с ОДНИМ вызовом HMAC
            async deterministicShuffle(array, key) {
                const result = [...array];
                const n = result.length;
                
                // ОДИН вызов HMAC для генерации seed
                const encoder = new TextEncoder();
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    key,
                    { name: 'HMAC', hash: 'SHA-512' },
                    false,
                    ['sign']
                );
                
                const hmacResult = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('shuffle_seed'));
                const prng = this.createPRNG(new Uint8Array(hmacResult));
                
                // Алгоритм Фишера-Йейтса
                for (let i = n - 1; i > 0; i--) {
                    const j = Math.floor(prng() * (i + 1));
                    [result[i], result[j]] = [result[j], result[i]];
                }
                
                return result;
            }
            
            // Generate homophone table based on derived key
            async generateHomophoneTable(password, iterations, progressCallback = null) {
                if (!password || password.length === 0) {
                    throw new Error('Password is required');
                }
                
                if (progressCallback) progressCallback(30, 'Deriving key with PBKDF2...');
                
                // Derive key using PBKDF2
                derivedKey = await this.deriveKey(password, iterations);
                if (progressCallback) progressCallback(60);
                
                // Initialize tables
                this.initializeTables();
                if (progressCallback) progressCallback(70, 'Generating homophone table...');
                
                // Create all possible homophones (00001 to 99999)
                const allHomophones = Array.from(
                    {length: TOTAL_HOMOPHONES}, 
                    (_, i) => (i + 1).toString().padStart(HOMOPHONE_LENGTH, '0')
                );
                
                // Deterministic shuffle based on derived key
                const shuffledHomophones = await this.deterministicShuffle(allHomophones, derivedKey);
                if (progressCallback) progressCallback(90);
                
                // Distribute homophones evenly among letters
                const homophonesPerLetter = Math.floor(TOTAL_HOMOPHONES / ALPHABET_SIZE);
                let homophoneIndex = 0;
                
                for (const letter of ALPHABET) {
                    // Assign homophones to this letter
                    homophoneTable[letter] = shuffledHomophones.slice(
                        homophoneIndex, 
                        homophoneIndex + homophonesPerLetter
                    );
                    
                    // Create reverse mapping
                    for (const homophone of homophoneTable[letter]) {
                        reverseHomophoneTable[homophone] = letter;
                    }
                    
                    homophoneIndex += homophonesPerLetter;
                }
                
                // Distribute remaining homophones (if any)
                const remainingHomophones = TOTAL_HOMOPHONES % ALPHABET_SIZE;
                if (remainingHomophones > 0) {
                    const extraHomophones = shuffledHomophones.slice(-remainingHomophones);
                    
                    // Distribute extra homophones evenly
                    for (let i = 0; i < remainingHomophones; i++) {
                        const letter = ALPHABET[i % ALPHABET_SIZE];
                        homophoneTable[letter].push(extraHomophones[i]);
                        reverseHomophoneTable[extraHomophones[i]] = letter;
                    }
                }
                
                if (progressCallback) progressCallback(100);
                return true;
            }
            
            // Affine transformation for additional security
            affineTransform(charIndex, position, prevCharIndex) {
                if (!config.affineMode) return charIndex;
                
                const a = config.affineA;
                const b = config.affineB;
                
                // Validate that 'a' is coprime with ALPHABET_SIZE
                if (!utils.validateAffineParam(a)) {
                    throw new Error(`Parameter a (${a}) must be coprime with ${ALPHABET_SIZE}`);
                }
                
                let result = (a * charIndex + b) % ALPHABET_SIZE;
                
                // Apply CBC mode if enabled - используем предыдущую букву и позицию
                if (config.cbcMode) {
                    result = (result + prevCharIndex + position) % ALPHABET_SIZE;
                }
                
                return result;
            }
            
            // Inverse affine transformation for decryption
            inverseAffineTransform(cipherNum, position, prevCharIndex) {
                if (!config.affineMode) return cipherNum;
                
                let result = cipherNum;
                
                // Reverse CBC mode if enabled
                if (config.cbcMode) {
                    result = (result - prevCharIndex - position) % ALPHABET_SIZE;
                    if (result < 0) result += ALPHABET_SIZE;
                }
                
                const a = config.affineA;
                const b = config.affineB;
                
                // Find modular inverse of a
                const aInv = utils.modInverse(a, ALPHABET_SIZE);
                
                result = (aInv * (result - b)) % ALPHABET_SIZE;
                return result < 0 ? result + ALPHABET_SIZE : result;
            }
            
            // Get a random homophone for a character (true randomness for non-deterministic encryption)
            getRandomHomophone(char) {
                const homophones = homophoneTable[char];
                if (!homophones || homophones.length === 0) {
                    throw new Error(`No homophones available for character: ${char}`);
                }
                
                // Use cryptographically secure random number generator
                const randomArray = new Uint32Array(1);
                crypto.getRandomValues(randomArray);
                const randomIndex = randomArray[0] % homophones.length;
                
                return homophones[randomIndex];
            }
            
            // Encrypt text using homophonic cipher with non-deterministic homophone selection
            async encrypt(plaintext) {
                const password = elements.cryptoKey.value;
                const iterations = parseInt(elements.keyIterations.value);
                
                if (!password) {
                    throw new Error('Password is required');
                }
                
                if (!plaintext) {
                    throw new Error('Plaintext is required');
                }
                
                // Generate homophone table based on password
                await this.generateHomophoneTable(password, iterations);
                
                const processedText = plaintext.toUpperCase().replace(/[^A-Z\s]/g, '');
                let ciphertext = [];
                let prevCharIndex = 0;
                let position = 0;
                
                // Process each character
                for (let char of processedText) {
                    if (char === ' ') {
                        ciphertext.push(' ');
                        continue;
                    }
                    
                    if (ALPHABET.includes(char)) {
                        // Get character index
                        const charIndex = ALPHABET.indexOf(char);
                        
                        // Apply affine transformation to the character index
                        const transformedIndex = this.affineTransform(charIndex, position, prevCharIndex);
                        const transformedChar = ALPHABET[transformedIndex];
                        
                        // Get random homophone for transformed character (non-deterministic)
                        const homophone = this.getRandomHomophone(transformedChar);
                        ciphertext.push(homophone);
                        
                        // Update state for CBC mode
                        if (config.cbcMode) {
                            prevCharIndex = transformedIndex;
                        }
                        
                        position++;
                    }
                }
                
                return ciphertext.join(' ');
            }
            
            // Decrypt text using homophonic cipher
            async decrypt(ciphertext) {
                const password = elements.cryptoKey.value;
                const iterations = parseInt(elements.keyIterations.value);
                
                if (!password) {
                    throw new Error('Password is required');
                }
                
                if (!ciphertext) {
                    throw new Error('Ciphertext is required');
                }
                
                // Generate homophone table based on password
                await this.generateHomophoneTable(password, iterations);
                
                let plaintext = [];
                const parts = ciphertext.split(/\s+/);
                let prevCharIndex = 0;
                let position = 0;
                
                // Process each part
                for (let part of parts) {
                    if (part === '') {
                        continue;
                    }
                    
                    // Check if this is a homophone (5-digit number)
                    if (/^\d{5}$/.test(part)) {
                        if (reverseHomophoneTable[part]) {
                            const cipherChar = reverseHomophoneTable[part];
                            const cipherNum = ALPHABET.indexOf(cipherChar);
                            
                            // Apply inverse affine transformation
                            const originalNum = this.inverseAffineTransform(cipherNum, position, prevCharIndex);
                            const originalChar = ALPHABET[originalNum];
                            
                            plaintext.push(originalChar);
                            
                            // Update state for CBC mode
                            if (config.cbcMode) {
                                prevCharIndex = cipherNum;
                            }
                            
                            position++;
                        } else {
                            plaintext.push('?');
                        }
                    } else {
                        // Preserve non-homophone parts (like spaces)
                        plaintext.push(part);
                    }
                }
                
                return plaintext.join('');
            }
        }

        // Application Controller
        const appController = {
            cipher: new HomophoneCipher(),
            
            init: function() {
                this.setupEventListeners();
                this.updateConfig();
                this.updateCharCounters();
                utils.showNotification('NeonHomophone Cipher initialized', 'success');
            },
            
            setupEventListeners: function() {
                // Encryption/Decryption buttons
                elements.encryptBtn.addEventListener('click', () => this.handleEncryption());
                elements.decryptBtn.addEventListener('click', () => this.handleDecryption());
                
                // Generate table button
                elements.generateBtn.addEventListener('click', () => this.handleGenerateTable());
                
                // Config change listeners
                elements.cbcMode.addEventListener('change', () => this.updateConfig());
                elements.affineMode.addEventListener('change', () => this.updateConfig());
                elements.affineA.addEventListener('change', () => this.updateConfig());
                elements.affineB.addEventListener('change', () => this.updateConfig());
                
                // Auto-generate table when key changes
                elements.cryptoKey.addEventListener('input', () => {
                    this.updateCharCounters();
                    if (elements.cryptoKey.value) {
                        this.handleGenerateTable();
                    }
                });
                
                // Character counters
                elements.plaintext.addEventListener('input', () => this.updateCharCounters());
                elements.ciphertext.addEventListener('input', () => this.updateCharCounters());
                
                // Update security level based on iterations
                elements.keyIterations.addEventListener('input', () => {
                    const iterations = parseInt(elements.keyIterations.value);
                    let securityLevel = '128-bit';
                    
                    if (iterations >= 300000) securityLevel = '192-bit';
                    if (iterations >= 600000) securityLevel = '256-bit';
                    if (iterations >= 900000) securityLevel = '320-bit';
                    
                    elements.securityLevel.textContent = securityLevel;
                });
            },
            
            updateConfig: function() {
                config.cbcMode = elements.cbcMode.checked;
                config.affineMode = elements.affineMode.checked;
                config.affineA = parseInt(elements.affineA.value);
                config.affineB = parseInt(elements.affineB.value);
                
                // Validate affine parameter a
                if (config.affineMode && !utils.validateAffineParam(config.affineA)) {
                    elements.status.textContent = 
                        `Warning: Parameter a (${config.affineA}) should be coprime with ${ALPHABET_SIZE}`;
                    elements.status.className = 'status error';
                }
            },
            
            updateCharCounters: function() {
                utils.updateCharCounter(elements.cryptoKey, 'keyLength');
                utils.updateCharCounter(elements.plaintext, 'plaintextLength');
                
                const ciphertextValue = elements.ciphertext.value;
                const homophoneCount = ciphertextValue ? ciphertextValue.trim().split(/\s+/).length : 0;
                elements.ciphertextInputLength.textContent = homophoneCount;
                
                // Update result counters
                const encryptionResult = elements.encryptionResult.textContent;
                if (encryptionResult) {
                    elements.ciphertextLength.textContent = encryptionResult ? encryptionResult.trim().split(/\s+/).length : 0;
                }
                
                const decryptionResult = elements.decryptionResult.textContent;
                if (decryptionResult) {
                    elements.decryptedLength.textContent = decryptionResult.length;
                }
            },
            
            handleGenerateTable: async function() {
                const password = elements.cryptoKey.value;
                const iterations = parseInt(elements.keyIterations.value);
                
                if (!password) {
                    elements.status.textContent = 'Error: Password is required';
                    elements.status.className = 'status error';
                    return;
                }
                
                try {
                    utils.setLoading('generate', true);
                    
                    await this.cipher.generateHomophoneTable(
                        password, 
                        iterations,
                        (progress, message) => {
                            elements.keyProgress.style.width = `${progress}%`;
                            if (message) {
                                elements.status.textContent = message;
                                elements.status.className = 'status success';
                            }
                        }
                    );
                    
                    elements.status.textContent = 'Homophone table generated successfully';
                    elements.status.className = 'status success';
                    utils.showNotification('Homophone table generated', 'success');
                    
                } catch (error) {
                    elements.status.textContent = `Error: ${error.message}`;
                    elements.status.className = 'status error';
                    utils.showNotification(`Error: ${error.message}`, 'error');
                } finally {
                    utils.setLoading('generate', false);
                }
            },
            
            handleEncryption: async function() {
                const plaintext = elements.plaintext.value;
                
                if (!plaintext) {
                    elements.encryptionResult.innerHTML = '<span style="color: var(--error)">Enter plaintext to encrypt</span>';
                    return;
                }
                
                try {
                    utils.setLoading('encrypt', true);
                    elements.status.textContent = 'Encrypting...';
                    
                    const ciphertext = await this.cipher.encrypt(plaintext);
                    
                    elements.encryptionResult.textContent = ciphertext;
                    elements.ciphertext.value = ciphertext;
                    elements.status.textContent = 'Encryption successful';
                    elements.status.className = 'status success';
                    
                    this.updateCharCounters();
                    utils.showNotification('Text encrypted successfully', 'success');
                    
                } catch (error) {
                    elements.encryptionResult.innerHTML = `<span style="color: var(--error)">Encryption error: ${error.message}</span>`;
                    elements.status.textContent = `Error: ${error.message}`;
                    elements.status.className = 'status error';
                    utils.showNotification(`Encryption error: ${error.message}`, 'error');
                } finally {
                    utils.setLoading('encrypt', false);
                }
            },
            
            handleDecryption: async function() {
                const ciphertext = elements.ciphertext.value;
                
                if (!ciphertext) {
                    elements.decryptionResult.innerHTML = '<span style="color: var(--error)">Enter ciphertext to decrypt</span>';
                    return;
                }
                
                try {
                    utils.setLoading('decrypt', true);
                    elements.status.textContent = 'Decrypting...';
                    
                    const plaintext = await this.cipher.decrypt(ciphertext);
                    
                    elements.decryptionResult.textContent = plaintext;
                    elements.status.textContent = 'Decryption successful';
                    elements.status.className = 'status success';
                    
                    this.updateCharCounters();
                    utils.showNotification('Text decrypted successfully', 'success');
                    
                } catch (error) {
                    elements.decryptionResult.innerHTML = `<span style="color: var(--error)">Decryption error: ${error.message}</span>`;
                    elements.status.textContent = `Error: ${error.message}`;
                    elements.status.className = 'status error';
                    utils.showNotification(`Decryption error: ${error.message}`, 'error');
                } finally {
                    utils.setLoading('decrypt', false);
                }
            }
        };

        // Start the application when the page loads
        window.addEventListener('load', () => appController.init());
    </script>
</body>
</html>
