<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Trifid Cipher Pro 8x8x8</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #3f37c9;
            --accent: #4895ef;
            --light: #f8f9fa;
            --dark: #212529;
            --gray: #6c757d;
            --light-gray: #e9ecef;
            --success: #4cc9f0;
            --error: #f72585;
            --warning: #f8961e;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
            --card-bg: rgba(255, 255, 255, 0.95);
            --input-bg: rgba(255, 255, 255, 0.9);
        }

        [data-theme="dark"] {
            --light: #121212;
            --dark: #f8f9fa;
            --gray: #adb5bd;
            --light-gray: #343a40;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            --card-bg: rgba(30, 30, 40, 0.95);
            --input-bg: rgba(40, 40, 50, 0.9);
            --primary: #4895ef;
            --primary-dark: #3f84d6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background-color: var(--light);
            min-height: 100vh;
            padding: 2rem;
            transition: var(--transition);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        h1, h2, h3, h4 {
            color: var(--primary);
            margin-bottom: 1rem;
            font-weight: 600;
        }

        h1 {
            font-size: 2rem;
        }

        h2 {
            font-size: 1.75rem;
        }

        h3 {
            font-size: 1.5rem;
        }

        h4 {
            font-size: 1.25rem;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        [data-theme="dark"] .card {
            border-color: rgba(255, 255, 255, 0.05);
        }

        .card:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--light-gray);
            padding-bottom: 0.5rem;
            flex-wrap: wrap;
        }

        .tab {
            padding: 0.75rem 1.25rem;
            background-color: rgba(0, 0, 0, 0.05);
            cursor: pointer;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
            transition: var(--transition);
            font-weight: 500;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        [data-theme="dark"] .tab {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .tab:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] .tab:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .tab.active {
            background-color: var(--primary);
            color: white;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.25rem;
            margin: 1.25rem 0;
        }

        .cube-layer {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 1rem;
            box-shadow: var(--box-shadow);
            border: 1px solid var(--light-gray);
        }

        .cube-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 0.5rem;
            font-size: 0.7rem;
        }

        .cube-table th, .cube-table td {
            border: 1px solid var(--light-gray);
            padding: 0.25rem;
            text-align: center;
            transition: var(--transition);
        }

        .cube-table th {
            background-color: var(--primary);
            color: white;
            font-weight: 600;
        }

        .cube-table td {
            background-color: var(--input-bg);
            font-family: 'Courier New', monospace;
        }

        .cube-table td:hover {
            background-color: var(--primary);
            color: white;
            transform: scale(1.05);
        }

        .form-group {
            margin-bottom: 1.25rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--dark);
            font-size: 0.95rem;
        }

        textarea, input[type="text"], input[type="number"], input[type="password"], select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--light-gray);
            border-radius: var(--border-radius);
            font-family: 'Courier New', monospace;
            transition: var(--transition);
            background-color: var(--input-bg);
            color: var(--dark);
            font-size: 0.95rem;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        textarea:focus, 
        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="password"]:focus,
        select:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 0.2rem rgba(67, 97, 238, 0.25);
            outline: none;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition);
            font-size: 0.95rem;
            white-space: nowrap;
        }

        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }

        .btn-outline:hover {
            background-color: var(--primary);
            color: white;
        }

        .btn-danger {
            background-color: var(--error);
        }

        .btn-danger:hover {
            background-color: #d1145a;
        }

        .btn-warning {
            background-color: var(--warning);
            color: var(--dark);
        }

        .btn-warning:hover {
            background-color: #e07d10;
        }

        .btn-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin-bottom: 1.25rem;
        }

        .alert {
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1.25rem;
            border-left: 4px solid transparent;
            font-size: 0.95rem;
        }

        .alert-success {
            background-color: rgba(76, 201, 240, 0.15);
            border-left-color: var(--success);
        }

        .alert-error {
            background-color: rgba(247, 37, 133, 0.15);
            border-left-color: var(--error);
        }

        .alert-warning {
            background-color: rgba(248, 150, 30, 0.15);
            border-left-color: var(--warning);
        }

        .process-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        .process-table th, .process-table td {
            border: 1px solid var(--light-gray);
            padding: 0.75rem;
            text-align: left;
        }

        .process-table th {
            background-color: var(--primary);
            color: white;
            font-weight: 600;
        }

        .process-table tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.03);
        }

        [data-theme="dark"] .process-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .theme-toggle {
            background: none;
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            color: var(--dark);
            transition: var(--transition);
            padding: 0.5rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .theme-toggle:hover {
            background-color: rgba(0, 0, 0, 0.05);
            transform: rotate(30deg);
        }

        [data-theme="dark"] .theme-toggle:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .settings-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .settings-group {
            flex: 1;
            min-width: 280px;
            background-color: rgba(0, 0, 0, 0.03);
            padding: 1rem;
            border-radius: var(--border-radius);
            border: 1px solid var(--light-gray);
        }

        [data-theme="dark"] .settings-group {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .settings-group h4 {
            margin-bottom: 0.75rem;
        }

        .error {
            color: var(--error);
            font-weight: bold;
        }

        .success {
            color: var(--success);
            font-weight: bold;
        }

        .warning {
            color: var(--warning);
            font-weight: bold;
        }

        .char-highlight {
            background-color: rgba(67, 97, 238, 0.2);
            padding: 0.1rem 0.25rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
        }

        .char-skipped {
            background-color: rgba(248, 150, 30, 0.2);
            padding: 0.1rem 0.25rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
        }

        .settings-file-input {
            display: none;
        }

        .settings-file-label {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background-color: rgba(67, 97, 238, 0.1);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.95rem;
        }

        .settings-file-label:hover {
            background-color: rgba(67, 97, 238, 0.2);
        }

        .readonly-field {
            background-color: rgba(0, 0, 0, 0.05) !important;
            cursor: not-allowed;
        }

        [data-theme="dark"] .readonly-field {
            background-color: rgba(255, 255, 255, 0.05) !important;
        }

        .round-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background-color: var(--primary);
            color: white;
            border-radius: 50%;
            font-size: 0.8rem;
            margin-right: 0.5rem;
            font-weight: bold;
        }

        .cube-title {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 0.75rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .security-meter {
            height: 8px;
            background-color: var(--light-gray);
            border-radius: 4px;
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .security-meter-fill {
            height: 100%;
            background-color: var(--success);
            width: 0%;
            transition: width 0.5s ease;
        }

        .password-strength {
            display: flex;
            justify-content: space-between;
            margin-top: 0.25rem;
            font-size: 0.8rem;
            color: var(--gray);
        }

        .password-strength span {
            transition: color 0.3s ease;
        }

        .password-strength .active {
            color: var(--success);
            font-weight: bold;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: var(--dark);
            color: var(--light);
            text-align: center;
            border-radius: var(--border-radius);
            padding: 0.75rem;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            font-weight: normal;
            box-shadow: var(--box-shadow);
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .status-icon {
            margin-right: 0.5rem;
        }

        .text-preview {
            font-family: 'Courier New', monospace;
            line-height: 1.8;
            word-break: break-all;
            padding: 0.5rem;
            background-color: var(--input-bg);
            border-radius: var(--border-radius);
            border: 1px solid var(--light-gray);
        }

        .copy-feedback {
            display: inline-block;
            margin-left: 0.5rem;
            color: var(--success);
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .copy-feedback.show {
            opacity: 1;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: var(--border-radius);
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--box-shadow);
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--gray);
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            .grid-container {
                grid-template-columns: 1fr;
            }
            
            .btn-group {
                gap: 0.5rem;
            }
            
            .settings-row {
                flex-direction: column;
                gap: 1rem;
            }
            
            .card {
                padding: 1rem;
            }
            
            h1 {
                font-size: 1.75rem;
            }
        }

        @media (max-width: 480px) {
            .tabs {
                overflow-x: auto;
                padding-bottom: 0.5rem;
                flex-wrap: nowrap;
                -webkit-overflow-scrolling: touch;
            }
            
            .tab {
                padding: 0.5rem 0.75rem;
                font-size: 0.85rem;
            }
            
            .btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-user-secret"></i> Secure Trifid Cipher Pro 8x8x8</h1>
            <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
                <i class="fas fa-moon"></i>
            </button>
        </header>

        <div class="card">
            <div class="tabs">
                <div class="tab active" data-tab="settings"><i class="fas fa-cog"></i> Settings</div>
                <div class="tab" data-tab="encrypt"><i class="fas fa-lock"></i> Encrypt</div>
                <div class="tab" data-tab="decrypt"><i class="fas fa-lock-open"></i> Decrypt</div>
                <div class="tab" data-tab="about"><i class="fas fa-info-circle"></i> About</div>
            </div>

            <div id="settings" class="tab-content active">
                <h2><i class="fas fa-sliders-h"></i> Cipher Configuration</h2>
                
                <div class="settings-row">
                    <div class="settings-group">
                        <h4><i class="fas fa-font"></i> Byte Range Settings</h4>
                        <div class="form-group">
                            <label for="byteRange">Byte Range (0-511)</label>
                            <input type="text" id="byteRange" value="0-511" readonly class="readonly-field">
                        </div>
                        
                        <div class="form-group">
                            <label for="filler">Filler byte (must NOT be in 0-511 range)</label>
                            <input type="number" id="filler" value="512" min="512" max="999">
                        </div>
                    </div>
                    
                    <div class="settings-group">
                        <h4><i class="fas fa-key"></i> Security Settings</h4>
                        <div class="form-group">
                            <label for="encryptionKey">
                                Encryption Key
                                <span class="tooltip">
                                    <i class="fas fa-question-circle"></i>
                                    <span class="tooltiptext">Use a strong passphrase with at least 12 characters</span>
                                </span>
                            </label>
                            <input type="password" id="encryptionKey" placeholder="Enter strong encryption key">
                            <div class="security-meter">
                                <div class="security-meter-fill" id="securityMeter"></div>
                            </div>
                            <div class="password-strength" id="passwordStrength">
                                <span data-level="1">Weak</span>
                                <span data-level="2">Medium</span>
                                <span data-level="3">Strong</span>
                                <span data-level="4">Very Strong</span>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="rounds">Encryption Rounds (3-10)</label>
                            <input type="number" id="rounds" min="3" max="10" value="5">
                        </div>
                    </div>
                </div>
                
                <div class="btn-group">
                    <button class="btn" id="initCubes"><i class="fas fa-cube"></i> Initialize Cubes</button>
                    <button class="btn btn-outline" id="resetCubes"><i class="fas fa-undo"></i> Reset Defaults</button>
                    <input type="file" id="settingsFileInput" class="settings-file-input" accept=".json,.txt">
                    <label for="settingsFileInput" class="settings-file-label" id="settingsFileLabel">
                        <i class="fas fa-file-import"></i> Load Settings
                    </label>
                    <button class="btn btn-outline" id="saveSettings"><i class="fas fa-file-export"></i> Save Settings</button>
                    <button class="btn btn-outline" id="advancedSettings"><i class="fas fa-cogs"></i> Advanced</button>
                </div>
                
                <div id="alphabetStatus" class="alert" style="display: none;"></div>
                
                <div id="cubesVisualization">
                    <h3><i class="fas fa-project-diagram"></i> Cryptographic Cubes (8x8x8)</h3>
                    <div id="cubesContainer"></div>
                </div>
            </div>

            <div id="encrypt" class="tab-content">
                <h2><i class="fas fa-lock"></i> Message Encryption</h2>
                
                <div class="form-group">
                    <label for="plaintext"><i class="fas fa-pen"></i> Plaintext Message (as bytes 0-511)</label>
                    <textarea id="plaintext" placeholder="Enter bytes (0-511) to encrypt, separated by spaces"></textarea>
                    <div class="text-preview" id="plaintextPreview"></div>
                </div>
                
                <div class="btn-group">
                    <button class="btn" id="encryptBtn"><i class="fas fa-key"></i> Encrypt</button>
                    <button class="btn btn-outline" id="clearPlaintext"><i class="fas fa-trash"></i> Clear</button>
                    <button class="btn btn-outline" id="samplePlaintext"><i class="fas fa-lightbulb"></i> Sample Bytes</button>
                </div>
                
                <div id="encryptionResult" class="alert alert-success" style="display: none;">
                    <h3><i class="fas fa-check-circle"></i> Encryption Successful</h3>
                    <p><strong>Ciphertext (bytes):</strong></p>
                    <div class="text-preview" id="ciphertextOutput"></div>
                    <button class="btn btn-outline" id="copyCiphertext"><i class="fas fa-copy"></i> Copy to Clipboard</button>
                    <span class="copy-feedback" id="cipherCopyFeedback">Copied!</span>
                </div>
                
                <div id="encryptionSteps" class="visualization"></div>
            </div>

            <div id="decrypt" class="tab-content">
                <h2><i class="fas fa-lock-open"></i> Message Decryption</h2>
                
                <div class="form-group">
                    <label for="ciphertext"><i class="fas fa-pen"></i> Ciphertext Message (as bytes 0-511)</label>
                    <textarea id="ciphertext" placeholder="Enter bytes (0-511) to decrypt, separated by spaces"></textarea>
                    <div class="text-preview" id="ciphertextPreview"></div>
                </div>
                
                <div class="btn-group">
                    <button class="btn" id="decryptBtn"><i class="fas fa-key"></i> Decrypt</button>
                    <button class="btn btn-outline" id="clearCiphertext"><i class="fas fa-trash"></i> Clear</button>
                    <button class="btn btn-outline" id="sampleCiphertext"><i class="fas fa-lightbulb"></i> Sample Bytes</button>
                </div>
                
                <div id="decryptionResult" class="alert alert-success" style="display: none;">
                    <h3><i class="fas fa-check-circle"></i> Decryption Successful</h3>
                    <p><strong>Plaintext (bytes):</strong></p>
                    <div class="text-preview" id="plaintextOutput"></div>
                    <button class="btn btn-outline" id="copyPlaintext"><i class="fas fa-copy"></i> Copy to Clipboard</button>
                    <span class="copy-feedback" id="plainCopyFeedback">Copied!</span>
                </div>
                
                <div id="decryptionSteps" class="visualization"></div>
            </div>

            <div id="about" class="tab-content">
                <h2><i class="fas fa-info-circle"></i> About Secure Trifid Cipher 8x8x8</h2>
                
                <div class="card">
                    <h3><i class="fas fa-question-circle"></i> Cryptographic Principles</h3>
                    <p>This enhanced Trifid cipher implementation provides significantly stronger security than classical versions through multiple cryptographic improvements:</p>
                    
                    <h4><i class="fas fa-shield-alt"></i> Security Enhancements:</h4>
                    <ul>
                        <li><strong>8x8x8 Cube Structure:</strong> Uses 512-byte cubes instead of traditional 4x4x4 character cubes</li>
                        <li><strong>Key-Based Cube Generation:</strong> Each round uses a unique cube derived from a cryptographic hash of the master key</li>
                        <li><strong>Multiple Encryption Rounds:</strong> Configurable rounds (3-10) with different cubes for each round</li>
                        <li><strong>Strong Key Derivation:</strong> Uses PBKDF2 with SHA-256 for key stretching (100,000 iterations)</li>
                        <li><strong>Diffusion:</strong> Each round completely transforms the data using different cubes</li>
                        <li><strong>Confusion:</strong> Complex relationship between key and ciphertext</li>
                    </ul>
                    
                    <h4><i class="fas fa-key"></i> Cube Generation Process:</h4>
                    <ol>
                        <li>Create master seed from encryption key using PBKDF2</li>
                        <li>For each round:
                            <ul>
                                <li>Derive round-specific seed using HMAC-SHA256</li>
                                <li>Shuffle byte range (0-511) using cryptographically secure Fisher-Yates algorithm</li>
                                <li>Fill 8×8×8 cube with shuffled bytes</li>
                            </ul>
                        </li>
                        <li>Verify all cubes are unique and properly filled</li>
                    </ol>

                    <h4><i class="fas fa-user-secret"></i> Security Recommendations:</h4>
                    <ul>
                        <li>Use a strong passphrase with at least 12 characters</li>
                        <li>Include uppercase, lowercase, numbers, and symbols in your key</li>
                        <li>Use at least 5 encryption rounds for sensitive data</li>
                        <li>Never reuse the same key for different purposes</li>
                        <li>Consider combining with other encryption methods for maximum security</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        class SecureTrifidCipher {
            constructor() {
                this.cubes = [];
                this.byteRange = Array.from({length: 512}, (_, i) => i); // 0-511
                this.fillerByte = 512; // Filler byte outside the 0-511 range
                this.encryptionKey = "";
                this.rounds = 5;
                this.salt = window.crypto.getRandomValues(new Uint8Array(16)).join('');
                this.fillMethod = "row";
                this.initEventListeners();
                this.initTheme();
                this.setupTextPreviews();
                this.setupPasswordStrengthMeter();
            }

            // ========================
            // Initialization Methods
            // ========================

            initEventListeners() {
                // Tab switching
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
                });

                // Core functionality
                document.getElementById('initCubes').addEventListener('click', () => this.initCubes());
                document.getElementById('resetCubes').addEventListener('click', () => this.resetToDefault());
                document.getElementById('encryptBtn').addEventListener('click', () => this.encrypt());
                document.getElementById('decryptBtn').addEventListener('click', () => this.decrypt());
                
                // Text management
                document.getElementById('clearPlaintext').addEventListener('click', () => {
                    document.getElementById('plaintext').value = '';
                    document.getElementById('plaintextPreview').textContent = '';
                });
                document.getElementById('clearCiphertext').addEventListener('click', () => {
                    document.getElementById('ciphertext').value = '';
                    document.getElementById('ciphertextPreview').textContent = '';
                });
                
                // Samples and copying
                document.getElementById('samplePlaintext').addEventListener('click', () => this.loadSampleText('plain'));
                document.getElementById('sampleCiphertext').addEventListener('click', () => this.loadSampleText('cipher'));
                document.getElementById('copyCiphertext').addEventListener('click', () => this.copyToClipboard('ciphertextOutput', 'cipherCopyFeedback'));
                document.getElementById('copyPlaintext').addEventListener('click', () => this.copyToClipboard('plaintextOutput', 'plainCopyFeedback'));
                
                // Settings management
                document.getElementById('themeToggle').addEventListener('click', () => this.toggleTheme());
                document.getElementById('saveSettings').addEventListener('click', () => this.saveSettingsToFile());
                document.getElementById('settingsFileInput').addEventListener('change', (e) => this.loadSettingsFromFile(e));
                document.getElementById('advancedSettings').addEventListener('click', () => this.showAdvancedSettings());
                
                // Dynamic updates
                document.getElementById('encryptionKey').addEventListener('input', (e) => {
                    this.encryptionKey = e.target.value;
                    this.updatePasswordStrength(e.target.value);
                });
                document.getElementById('rounds').addEventListener('change', (e) => {
                    this.rounds = Math.min(10, Math.max(3, parseInt(e.target.value)));
                });
                document.getElementById('filler').addEventListener('change', (e) => {
                    this.fillerByte = parseInt(e.target.value);
                });
            }

            setupTextPreviews() {
                document.getElementById('plaintext').addEventListener('input', (e) => {
                    this.updateTextPreview(e.target.value, 'plaintextPreview');
                });
                document.getElementById('ciphertext').addEventListener('input', (e) => {
                    this.updateTextPreview(e.target.value, 'ciphertextPreview');
                });
            }

            setupPasswordStrengthMeter() {
                document.getElementById('encryptionKey').addEventListener('input', (e) => {
                    this.updatePasswordStrength(e.target.value);
                });
            }

            initTheme() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.body.setAttribute('data-theme', savedTheme);
                this.updateThemeIcon(savedTheme);
            }

            // ========================
            // Core Cipher Methods
            // ========================

            async initCubes() {
                const newFiller = parseInt(document.getElementById('filler').value);
                const statusElement = document.getElementById('alphabetStatus');

                // Validate filler
                if (newFiller < 512 || newFiller > 999) {
                    this.showError(statusElement, "Filler byte must be between 512 and 999");
                    return false;
                }

                if (this.byteRange.includes(newFiller)) {
                    this.showError(statusElement, "Filler byte must NOT be in 0-511 range");
                    return false;
                }

                // Store validated values
                this.fillerByte = newFiller;
                this.encryptionKey = document.getElementById('encryptionKey').value;
                this.rounds = parseInt(document.getElementById('rounds').value);

                try {
                    // Generate cubes for all rounds
                    await this.generateAllCubes();

                    // Update previews
                    this.updateTextPreview(document.getElementById('plaintext').value, 'plaintextPreview');
                    this.updateTextPreview(document.getElementById('ciphertext').value, 'ciphertextPreview');

                    // Show success
                    this.showSuccess(statusElement, `Successfully generated ${this.rounds} cryptographically secure 8x8x8 cubes`);
                    
                    // Visualize cubes
                    this.visualizeCubes();

                    return true;
                } catch (error) {
                    this.showError(statusElement, `Error during cube generation: ${error.message}`);
                    console.error("Cube generation error:", error);
                    return false;
                }
            }

            async generateAllCubes() {
                this.cubes = [];
                const key = this.encryptionKey;
                
                try {
                    if (!key) {
                        // Without key - use sequential order
                        if (!confirm("Warning: No encryption key provided. Using default sequential cube order which provides NO SECURITY. Continue?")) {
                            throw new Error("Cube generation canceled");
                        }
                        const cube = this.generateSequentialCube();
                        for (let round = 0; round < this.rounds; round++) {
                            this.cubes.push(JSON.parse(JSON.stringify(cube))); // Deep copy
                        }
                    } else {
                        // With key - deterministic generation
                        const masterSeed = await this.deriveKey(key, this.salt, 100000);
                        
                        for (let round = 0; round < this.rounds; round++) {
                            const roundSeed = await this.hmacSha256(masterSeed, round.toString());
                            const cube = await this.generateCubeFromSeed(roundSeed);
                            this.cubes.push(cube);
                        }
                    }
                    
                    this.verifyCubeUniqueness();
                } catch (error) {
                    console.error("Error in cube generation:", error);
                    throw error;
                }
            }

            generateSequentialCube() {
                const cube = [];
                let pos = 0;
                
                for (let layer = 0; layer < 8; layer++) {
                    const cubeLayer = [];
                    for (let row = 0; row < 8; row++) {
                        const cubeRow = [];
                        for (let col = 0; col < 8; col++) {
                            cubeRow.push(this.byteRange[pos++ % this.byteRange.length]);
                        }
                        cubeLayer.push(cubeRow);
                    }
                    cube.push(cubeLayer);
                }
                
                return cube;
            }

            async generateCubeFromSeed(seed) {
                const shuffledBytes = await this.deterministicShuffle(this.byteRange, seed);
                
                switch(this.fillMethod) {
                    case 'column': return this.fillByColumns(shuffledBytes);
                    case 'diagonal': return this.fillDiagonal(shuffledBytes);
                    case 'spiral': return this.fillSpiral(shuffledBytes);
                    case 'checkerboard': return this.fillCheckerboard(shuffledBytes);
                    default: return this.fillByRows(shuffledBytes);
                }
            }

            // ========================
            // Cube Fill Methods
            // ========================

            fillByRows(shuffledBytes) {
                const cube = [];
                let pos = 0;
                
                for (let layer = 0; layer < 8; layer++) {
                    const cubeLayer = [];
                    for (let row = 0; row < 8; row++) {
                        const cubeRow = [];
                        for (let col = 0; col < 8; col++) {
                            cubeRow.push(shuffledBytes[pos++ % shuffledBytes.length]);
                        }
                        cubeLayer.push(cubeRow);
                    }
                    cube.push(cubeLayer);
                }
                
                return cube;
            }

            fillByColumns(shuffledBytes) {
                const cube = [];
                let pos = 0;
                
                for (let layer = 0; layer < 8; layer++) {
                    const cubeLayer = [];
                    for (let col = 0; col < 8; col++) {
                        const cubeCol = [];
                        for (let row = 0; row < 8; row++) {
                            cubeCol.push(shuffledBytes[pos++ % shuffledBytes.length]);
                        }
                        cubeLayer.push(cubeCol);
                    }
                    cube.push(cubeLayer);
                }
                
                return cube;
            }

            fillDiagonal(shuffledBytes) {
                const cube = [];
                let pos = 0;
                
                for (let layer = 0; layer < 8; layer++) {
                    const cubeLayer = Array(8).fill().map(() => Array(8).fill(null));
                    
                    // Fill diagonals
                    for (let diag = 0; diag < 15; diag++) {
                        for (let row = 0; row < 8; row++) {
                            const col = diag - row;
                            if (col >= 0 && col < 8 && cubeLayer[row][col] === null) {
                                cubeLayer[row][col] = shuffledBytes[pos++ % shuffledBytes.length];
                            }
                        }
                    }
                    cube.push(cubeLayer);
                }
                
                return cube;
            }

            fillSpiral(shuffledBytes) {
                const cube = [];
                let pos = 0;
                
                for (let layer = 0; layer < 8; layer++) {
                    const cubeLayer = Array(8).fill().map(() => Array(8).fill(null));
                    let top = 0, bottom = 7, left = 0, right = 7;
                    let direction = 0; // 0: right, 1: down, 2: left, 3: up
                    
                    while (top <= bottom && left <= right) {
                        if (direction === 0) {
                            for (let i = left; i <= right; i++) {
                                cubeLayer[top][i] = shuffledBytes[pos++ % shuffledBytes.length];
                            }
                            top++;
                        } else if (direction === 1) {
                            for (let i = top; i <= bottom; i++) {
                                cubeLayer[i][right] = shuffledBytes[pos++ % shuffledBytes.length];
                            }
                            right--;
                        } else if (direction === 2) {
                            for (let i = right; i >= left; i--) {
                                cubeLayer[bottom][i] = shuffledBytes[pos++ % shuffledBytes.length];
                            }
                            bottom--;
                        } else if (direction === 3) {
                            for (let i = bottom; i >= top; i--) {
                                cubeLayer[i][left] = shuffledBytes[pos++ % shuffledBytes.length];
                            }
                            left++;
                        }
                        direction = (direction + 1) % 4;
                    }
                    cube.push(cubeLayer);
                }
                
                return cube;
            }

            fillCheckerboard(shuffledBytes) {
                const cube = [];
                let pos = 0;
                let reversePos = shuffledBytes.length - 1;
                
                for (let layer = 0; layer < 8; layer++) {
                    const cubeLayer = [];
                    for (let row = 0; row < 8; row++) {
                        const cubeRow = [];
                        for (let col = 0; col < 8; col++) {
                            const index = (row % 2 === col % 2) 
                                ? pos++ 
                                : reversePos--;
                            cubeRow.push(shuffledBytes[index % shuffledBytes.length]);
                        }
                        cubeLayer.push(cubeRow);
                    }
                    cube.push(cubeLayer);
                }
                
                return cube;
            }

            // ========================
            // Cryptographic Helpers
            // ========================

            async deterministicShuffle(array, seedString) {
                // 1. Convert seed to bytes via HMAC-SHA256
                const seed = await this.hmacSha256(seedString, "shuffle-seed");
                
                // 2. Convert hex hash to number array
                const hashArray = [];
                for (let i = 0; i < seed.length; i += 2) {
                    hashArray.push(parseInt(seed.substr(i, 2), 16));
                }
                
                // 3. Fisher-Yates with deterministic selection
                const arr = [...array];
                let hashIndex = 0;
                
                for (let i = arr.length - 1; i > 0; i--) {
                    // Get bytes from hash cyclically
                    const randomByte = hashArray[hashIndex % hashArray.length];
                    hashIndex++;
                    
                    // Calculate swap index
                    const j = randomByte % (i + 1);
                    
                    // Swap
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                
                return arr;
            }

            async deriveKey(password, salt, iterations) {
                const encoder = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits']
                );
                
                const derivedBits = await window.crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: encoder.encode(salt),
                        iterations: iterations,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    256
                );
                
                return this.arrayBufferToHex(derivedBits);
            }

            async hmacSha256(key, message) {
                const encoder = new TextEncoder();
                const cryptoKey = await window.crypto.subtle.importKey(
                    'raw',
                    encoder.encode(key),
                    { name: 'HMAC', hash: 'SHA-256' },
                    false,
                    ['sign']
                );
                
                const signature = await window.crypto.subtle.sign(
                    'HMAC',
                    cryptoKey,
                    encoder.encode(message)
                );
                
                return this.arrayBufferToHex(signature);
            }

            arrayBufferToHex(buffer) {
                return Array.from(new Uint8Array(buffer))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            }

            verifyCubeUniqueness() {
                const cubeHashes = new Set();
                
                for (const cube of this.cubes) {
                    const cubeString = JSON.stringify(cube);
                    const cubeHash = this.hashString(cubeString);
                    
                    if (cubeHashes.has(cubeHash)) {
                        throw new Error("Duplicate cube detected - increase key complexity or rounds");
                    }
                    cubeHashes.add(cubeHash);
                }
            }

            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = (hash << 5) - hash + char;
                    hash |= 0;
                }
                return hash.toString(36);
            }

            // ========================
            // Encryption/Decryption
            // ========================

            parseByteInput(input) {
                if (!input.trim()) return [];
                
                // Try to parse as space-separated bytes
                const bytes = input.trim().split(/\s+/).map(byte => {
                    const num = parseInt(byte);
                    return isNaN(num) ? null : num;
                });
                
                // Check for invalid bytes
                const invalidBytes = bytes.filter(byte => byte === null || byte < 0 || byte > 511);
                if (invalidBytes.length > 0) {
                    throw new Error("Input contains invalid bytes. All bytes must be integers between 0 and 511.");
                }
                
                return bytes;
            }

            formatBytes(bytes) {
                return bytes.map(byte => byte.toString().padStart(3, '0')).join(' ');
            }

            async encrypt() {
                const plaintextInput = document.getElementById('plaintext').value;
                if (!plaintextInput) {
                    alert("Please enter some bytes to encrypt");
                    return;
                }

                if (this.cubes.length === 0) {
                    alert("Please initialize cubes first");
                    return;
                }

                try {
                    const plaintextBytes = this.parseByteInput(plaintextInput);
                    let intermediate = plaintextBytes;
                    let stepsHTML = '<div class="card"><h3><i class="fas fa-sync-alt"></i> Multi-Round Encryption Process</h3>';
                    stepsHTML += `<p>Using ${this.rounds} encryption rounds with key-based cubes</p>`;

                    for (let round = 0; round < this.rounds; round++) {
                        stepsHTML += `<div class="card"><h4><span class="round-badge">${round+1}</span> Encryption Round ${round+1}/${this.rounds}</h4>`;
                        
                        const roundResult = this.singleRoundEncrypt(intermediate, round);
                        intermediate = roundResult.ciphertext;
                        
                        stepsHTML += roundResult.steps;
                        stepsHTML += `<p><strong>Round ${round+1} output:</strong> <code>${this.formatBytes(intermediate)}</code></p>`;
                        stepsHTML += '</div>';
                    }

                    stepsHTML += '</div>';

                    document.getElementById('encryptionResult').style.display = 'block';
                    document.getElementById('ciphertextOutput').textContent = this.formatBytes(intermediate);
                    document.getElementById('encryptionSteps').innerHTML = stepsHTML;
                    this.updateTextPreview(this.formatBytes(intermediate), 'ciphertextPreview');
                } catch (error) {
                    console.error("Encryption error:", error);
                    alert(`Encryption failed: ${error.message}`);
                }
            }

            singleRoundEncrypt(bytes, round) {
                let stepsHTML = '';
                let coordinates = [];
                let skippedBytes = [];
                
                // Generate coordinate table
                let coordTable = `
                    <table class="process-table">
                        <thead>
                            <tr>
                                <th>Byte</th>
                                <th>Layer</th>
                                <th>Row</th>
                                <th>Column</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                // Find coordinates for each byte
                for (let byte of bytes) {
                    const coord = this.findCoordinates(byte, round);
                    if (coord) {
                        coordinates.push(coord);
                        coordTable += `
                            <tr>
                                <td><code>${byte.toString().padStart(3, '0')}</code></td>
                                <td>${coord.layer}</td>
                                <td>${coord.row}</td>
                                <td>${coord.col}</td>
                            </tr>
                        `;
                    } else {
                        skippedBytes.push(byte);
                        coordTable += `
                            <tr>
                                <td><code>${byte.toString().padStart(3, '0')}</code></td>
                                <td colspan="3" class="error">(Not in cube - preserved)</td>
                            </tr>
                        `;
                    }
                }
                coordTable += `</tbody></table>`;
                stepsHTML += coordTable;

                // Handle case where no bytes are in cube
                if (coordinates.length === 0) {
                    return {
                        ciphertext: bytes,
                        steps: stepsHTML + `<p class="warning">No bytes in the input were found in the cube. No encryption performed this round.</p>`
                    };
                }

                // Create coordinate streams
                let layersStream = coordinates.map(c => c.layer).join('');
                let rowsStream = coordinates.map(c => c.row).join('');
                let colsStream = coordinates.map(c => c.col).join('');
                let combinedStream = layersStream + rowsStream + colsStream;

                stepsHTML += `
                    <p><strong>Layers stream:</strong> <code>${this.chunkString(layersStream, 5)}</code></p>
                    <p><strong>Rows stream:</strong> <code>${this.chunkString(rowsStream, 5)}</code></p>
                    <p><strong>Columns stream:</strong> <code>${this.chunkString(colsStream, 5)}</code></p>
                    <p><strong>Combined stream:</strong> <code>${this.chunkString(combinedStream, 5)}</code></p>
                `;

                // Generate ciphertext from triplets
                let ciphertext = [];
                let tripletTable = `
                    <table class="process-table">
                        <thead>
                            <tr>
                                <th>Triplet</th>
                                <th>Layer</th>
                                <th>Row</th>
                                <th>Column</th>
                                <th>Byte</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                for (let i = 0; i < combinedStream.length; i += 3) {
                    let triplet = combinedStream.substr(i, 3);
                    if (triplet.length === 3) {
                        const layer = parseInt(triplet[0]);
                        const row = parseInt(triplet[1]);
                        const col = parseInt(triplet[2]);
                        const byte = this.getByteFromCoordinates(layer, row, col, round);
                        ciphertext.push(byte);
                        
                        tripletTable += `
                            <tr>
                                <td><code>${triplet}</code></td>
                                <td>${layer}</td>
                                <td>${row}</td>
                                <td>${col}</td>
                                <td><code>${byte.toString().padStart(3, '0')}</code></td>
                            </tr>
                        `;
                    } else {
                        ciphertext.push(this.fillerByte);
                        tripletTable += `
                            <tr>
                                <td><code>${triplet}</code></td>
                                <td colspan="4" class="error">(Incomplete triplet - using filler)</td>
                            </tr>
                        `;
                    }
                }
                tripletTable += `</tbody></table>`;
                stepsHTML += tripletTable;

                // Reinsert skipped bytes if any
                if (skippedBytes.length > 0) {
                    let originalIndex = 0;
                    let cipherIndex = 0;
                    let finalCiphertext = [];
                    
                    for (let byte of bytes) {
                        const coord = this.findCoordinates(byte, round);
                        if (coord) {
                            if (cipherIndex < ciphertext.length) {
                                finalCiphertext.push(ciphertext[cipherIndex++]);
                            } else {
                                finalCiphertext.push(this.fillerByte);
                            }
                        } else {
                            finalCiphertext.push(byte);
                        }
                    }
                    
                    if (cipherIndex < ciphertext.length) {
                        finalCiphertext = finalCiphertext.concat(ciphertext.slice(cipherIndex));
                    }
                    
                    ciphertext = finalCiphertext;
                    
                    stepsHTML += `<p><i class="fas fa-exchange-alt"></i> Reinserted ${skippedBytes.length} preserved bytes at original positions</p>`;
                }

                return {
                    ciphertext: ciphertext,
                    steps: stepsHTML
                };
            }

            async decrypt() {
                const ciphertextInput = document.getElementById('ciphertext').value;
                if (!ciphertextInput) {
                    alert("Please enter some bytes to decrypt");
                    return;
                }

                if (this.cubes.length === 0) {
                    alert("Please initialize cubes first");
                    return;
                }

                try {
                    const ciphertextBytes = this.parseByteInput(ciphertextInput);
                    let intermediate = ciphertextBytes;
                    let stepsHTML = '<div class="card"><h3><i class="fas fa-sync-alt"></i> Multi-Round Decryption Process</h3>';
                    stepsHTML += `<p>Using ${this.rounds} decryption rounds with key-based cubes</p>`;

                    // Perform decryption in reverse round order
                    for (let round = this.rounds - 1; round >= 0; round--) {
                        stepsHTML += `<div class="card"><h4><span class="round-badge">${this.rounds-round}</span> Decryption Round ${this.rounds-round}/${this.rounds}</h4>`;
                        
                        const roundResult = this.singleRoundDecrypt(intermediate, round);
                        intermediate = roundResult.plaintext;
                        
                        stepsHTML += roundResult.steps;
                        stepsHTML += `<p><strong>Round ${this.rounds-round} output:</strong> <code>${this.formatBytes(intermediate)}</code></p>`;
                        stepsHTML += '</div>';
                    }

                    stepsHTML += '</div>';

                    document.getElementById('decryptionResult').style.display = 'block';
                    document.getElementById('plaintextOutput').textContent = this.formatBytes(intermediate);
                    document.getElementById('decryptionSteps').innerHTML = stepsHTML;
                    this.updateTextPreview(this.formatBytes(intermediate), 'plaintextPreview');
                } catch (error) {
                    console.error("Decryption error:", error);
                    alert(`Decryption failed: ${error.message}`);
                }
            }

            singleRoundDecrypt(bytes, round) {
                let stepsHTML = '';
                let coordinates = [];
                let skippedBytes = [];
                
                // Generate coordinate table
                let coordTable = `
                    <table class="process-table">
                        <thead>
                            <tr>
                                <th>Byte</th>
                                <th>Layer</th>
                                <th>Row</th>
                                <th>Column</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                // Find coordinates for each byte
                for (let byte of bytes) {
                    const coord = this.findCoordinates(byte, round);
                    if (coord) {
                        coordinates.push(coord);
                        coordTable += `
                            <tr>
                                <td><code>${byte.toString().padStart(3, '0')}</code></td>
                                <td>${coord.layer}</td>
                                <td>${coord.row}</td>
                                <td>${coord.col}</td>
                            </tr>
                        `;
                    } else {
                        skippedBytes.push(byte);
                        coordTable += `
                            <tr>
                                <td><code>${byte.toString().padStart(3, '0')}</code></td>
                                <td colspan="3" class="error">(Not in cube - preserved)</td>
                            </tr>
                        `;
                    }
                }
                coordTable += `</tbody></table>`;
                stepsHTML += coordTable;

                // Handle case where no bytes are in cube
                if (coordinates.length === 0) {
                    return {
                        plaintext: bytes,
                        steps: stepsHTML + `<p class="warning">No bytes in the input were found in the cube. No decryption performed this round.</p>`
                    };
                }

                // Create full coordinate sequence
                let coordSequence = '';
                for (let coord of coordinates) {
                    coordSequence += coord.layer + '' + coord.row + '' + coord.col;
                }

                stepsHTML += `
                    <p><strong>Full coordinate sequence:</strong> <code>${this.chunkString(coordSequence, 5)}</code></p>
                `;

                // Split into three equal parts
                const partLength = Math.floor(coordSequence.length / 3);
                const layersPart = coordSequence.substring(0, partLength);
                const rowsPart = coordSequence.substring(partLength, 2 * partLength);
                const colsPart = coordSequence.substring(2 * partLength);

                stepsHTML += `
                    <p><strong>Layers part:</strong> <code>${this.chunkString(layersPart, 5)}</code></p>
                    <p><strong>Rows part:</strong> <code>${this.chunkString(rowsPart, 5)}</code></p>
                    <p><strong>Columns part:</strong> <code>${this.chunkString(colsPart, 5)}</code></p>
                `;

                // Reconstruct plaintext
                let plaintext = [];
                let reconstructionTable = `
                    <table class="process-table">
                        <thead>
                            <tr>
                                <th>Position</th>
                                <th>Layer</th>
                                <th>Row</th>
                                <th>Column</th>
                                <th>Byte</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                for (let i = 0; i < layersPart.length; i++) {
                    const layer = parseInt(layersPart[i]);
                    const row = parseInt(rowsPart[i]);
                    const col = parseInt(colsPart[i]);
                    const byte = this.getByteFromCoordinates(layer, row, col, round);
                    plaintext.push(byte);
                    
                    reconstructionTable += `
                        <tr>
                            <td>${i + 1}</td>
                            <td>${layer}</td>
                            <td>${row}</td>
                            <td>${col}</td>
                            <td><code>${byte.toString().padStart(3, '0')}</code></td>
                        </tr>
                    `;
                }
                reconstructionTable += `</tbody></table>`;
                stepsHTML += reconstructionTable;

                // Reinsert skipped bytes if any
                if (skippedBytes.length > 0) {
                    let originalIndex = 0;
                    let plainIndex = 0;
                    let finalPlaintext = [];
                    
                    for (let byte of bytes) {
                        const coord = this.findCoordinates(byte, round);
                        if (coord) {
                            if (plainIndex < plaintext.length) {
                                finalPlaintext.push(plaintext[plainIndex++]);
                            } else {
                                finalPlaintext.push(this.fillerByte);
                            }
                        } else {
                            finalPlaintext.push(byte);
                        }
                    }
                    
                    if (plainIndex < plaintext.length) {
                        finalPlaintext = finalPlaintext.concat(plaintext.slice(plainIndex));
                    }
                    
                    plaintext = finalPlaintext;
                    
                    stepsHTML += `<p><i class="fas fa-exchange-alt"></i> Reinserted ${skippedBytes.length} preserved bytes at original positions</p>`;
                }

                return {
                    plaintext: plaintext,
                    steps: stepsHTML
                };
            }

            // ========================
            // Helper Methods
            // ========================

            findCoordinates(byte, round) {
                if (round >= this.cubes.length) return null;
                
                const cube = this.cubes[round];
                for (let layer = 0; layer < 8; layer++) {
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            if (cube[layer][row][col] === byte) {
                                return { layer: layer + 1, row: row + 1, col: col + 1 };
                            }
                        }
                    }
                }
                return null;
            }

            getByteFromCoordinates(layer, row, col, round) {
                if (round >= this.cubes.length || 
                    layer < 1 || layer > 8 || 
                    row < 1 || row > 8 || 
                    col < 1 || col > 8) {
                    return this.fillerByte;
                }
                return this.cubes[round][layer - 1][row - 1][col - 1];
            }

            updateTextPreview(text, elementId) {
                if (this.cubes.length === 0) {
                    document.getElementById(elementId).innerHTML = '<span class="warning">Please initialize cubes first</span>';
                    return;
                }

                try {
                    const bytes = this.parseByteInput(text);
                    let previewHtml = '';
                    
                    for (const byte of bytes) {
                        const coord = this.findCoordinates(byte, 0); // Use first cube for preview
                        if (coord) {
                            previewHtml += `<span class="char-highlight" title="Layer: ${coord.layer}, Row: ${coord.row}, Col: ${coord.col}">${byte.toString().padStart(3, '0')}</span> `;
                        } else if (byte === this.fillerByte) {
                            previewHtml += `<span class="char-skipped" title="Filler byte">${byte.toString().padStart(3, '0')}</span> `;
                        } else {
                            previewHtml += `<span class="char-skipped" title="Byte not in cube - will be preserved">${byte.toString().padStart(3, '0')}</span> `;
                        }
                    }
                    
                    document.getElementById(elementId).innerHTML = previewHtml || '<span class="warning">No bytes to preview</span>';
                } catch (error) {
                    document.getElementById(elementId).innerHTML = `<span class="error">${error.message}</span>`;
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            chunkString(str, size) {
                if (!str) return '';
                const chunks = [];
                for (let i = 0; i < str.length; i += size) {
                    chunks.push(str.substr(i, size));
                }
                return chunks.join(' ');
            }

            loadSampleText(type) {
                const samples = {
                    plain: "65 120 97 109 112 108 101 32 98 121 116 101 115 32 102 111 114 32 101 110 99 114 121 112 116 105 111 110",
                    cipher: ""
                };

                if (type === 'cipher' && this.cubes.length > 0) {
                    try {
                        const plainBytes = this.parseByteInput(samples.plain);
                        samples.cipher = this.formatBytes(this.generateCiphertext(plainBytes));
                    } catch (e) {
                        samples.cipher = "Initialize cubes first to generate sample ciphertext";
                    }
                }

                const elementId = type === 'plain' ? 'plaintext' : 'ciphertext';
                const previewId = type === 'plain' ? 'plaintextPreview' : 'ciphertextPreview';
                document.getElementById(elementId).value = samples[type];
                this.updateTextPreview(samples[type], previewId);
            }

            generateCiphertext(bytes) {
                let ciphertext = [];
                const coordinates = [];
                
                // Use first cube for sample generation
                const round = 0;
                
                // Find coordinates for all bytes
                for (let byte of bytes) {
                    const coord = this.findCoordinates(byte, round);
                    if (coord) coordinates.push(coord);
                }
                
                // Create coordinate streams
                const layersStream = coordinates.map(c => c.layer).join('');
                const rowsStream = coordinates.map(c => c.row).join('');
                const colsStream = coordinates.map(c => c.col).join('');
                const combinedStream = layersStream + rowsStream + colsStream;
                
                // Generate ciphertext from triplets
                for (let i = 0; i < combinedStream.length; i += 3) {
                    const triplet = combinedStream.substr(i, 3);
                    if (triplet.length === 3) {
                        const layer = parseInt(triplet[0]);
                        const row = parseInt(triplet[1]);
                        const col = parseInt(triplet[2]);
                        ciphertext.push(this.getByteFromCoordinates(layer, row, col, round));
                    } else {
                        ciphertext.push(this.fillerByte);
                    }
                }
                
                return ciphertext;
            }

            // ========================
            // UI Methods
            // ========================

            showAdvancedSettings() {
                const modalHtml = `
                    <div class="modal-overlay">
                        <div class="modal-content">
                            <button class="modal-close">&times;</button>
                            <h3><i class="fas fa-cogs"></i> Advanced Settings</h3>
                            
                            <div class="form-group">
                                <label for="fillMethod">Cube Fill Method:</label>
                                <select id="fillMethod">
                                    <option value="row">By Rows (Default)</option>
                                    <option value="column">By Columns</option>
                                    <option value="diagonal">Diagonal</option>
                                    <option value="spiral">Spiral</option>
                                    <option value="checkerboard">Checkerboard</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="saltInput">PBKDF2 Salt</label>
                                <input type="text" id="saltInput" value="${this.salt}">
                                <button class="btn" id="generateSalt">Generate New Salt</button>
                            </div>
                            
                            <div class="form-group">
                                <label for="iterations">PBKDF2 Iterations (10,000-1,000,000)</label>
                                <input type="number" id="iterations" value="100000" min="10000" max="1000000">
                            </div>
                            
                            <div class="btn-group">
                                <button class="btn" id="saveAdvanced">Save Settings</button>
                                <button class="btn btn-outline" id="cancelAdvanced">Cancel</button>
                            </div>
                        </div>
                    </div>
                `;
                
                const modal = document.createElement('div');
                modal.innerHTML = modalHtml;
                document.body.appendChild(modal);
                
                // Set current values
                modal.querySelector('#fillMethod').value = this.fillMethod;
                modal.querySelector('#iterations').value = 100000;
                
                // Event handlers
                modal.querySelector('#generateSalt').addEventListener('click', () => {
                    this.salt = window.crypto.getRandomValues(new Uint8Array(16)).join('');
                    modal.querySelector('#saltInput').value = this.salt;
                });
                
                modal.querySelector('#saveAdvanced').addEventListener('click', () => {
                    this.fillMethod = modal.querySelector('#fillMethod').value;
                    this.salt = modal.querySelector('#saltInput').value;
                    modal.remove();
                });
                
                const closeModal = () => modal.remove();
                modal.querySelector('.modal-close').addEventListener('click', closeModal);
                modal.querySelector('#cancelAdvanced').addEventListener('click', closeModal);
                modal.querySelector('.modal-overlay').addEventListener('click', (e) => {
                    if (e.target === modal.querySelector('.modal-overlay')) {
                        closeModal();
                    }
                });
            }

            visualizeCubes() {
                const container = document.getElementById('cubesContainer');
                container.innerHTML = '';

                if (this.cubes.length === 0) {
                    container.innerHTML = '<div class="alert alert-warning">No cubes generated yet</div>';
                    return;
                }

                // Show only first cube for performance reasons
                const cube = this.cubes[0];
                const roundDiv = document.createElement('div');
                roundDiv.className = 'card';
                roundDiv.innerHTML = `
                    <h4 class="cube-title">
                        <span class="round-badge">1</span>
                        Encryption Round 1 Cube (8x8x8)
                    </h4>
                    <p><i>Note: Only showing first cube for performance. All ${this.rounds} cubes have been generated.</i></p>
                `;
                
                const grid = document.createElement('div');
                grid.className = 'grid-container';
                
                // Show only first 4 layers for performance
                for (let layerIdx = 0; layerIdx < Math.min(4, cube.length); layerIdx++) {
                    const layer = cube[layerIdx];
                    const layerDiv = document.createElement('div');
                    layerDiv.className = 'cube-layer';
                    
                    const table = document.createElement('table');
                    table.className = 'cube-table';
                    
                    const caption = table.createCaption();
                    caption.textContent = `Layer ${layerIdx + 1}`;
                    caption.style.captionSide = 'top';
                    caption.style.marginBottom = '0.5rem';

                    // Header row
                    const headerRow = table.insertRow();
                    const emptyHeader = headerRow.insertCell();
                    emptyHeader.textContent = 'R\\C';
                    emptyHeader.className = 'row-header';

                    // Column headers
                    for (let col = 0; col < 8; col++) {
                        const th = headerRow.insertCell();
                        th.textContent = col + 1;
                        th.className = 'column-header';
                    }

                    // Table body
                    for (let rowIdx = 0; rowIdx < 8; rowIdx++) {
                        const row = layer[rowIdx];
                        const tr = table.insertRow();
                        const rowHeader = tr.insertCell();
                        rowHeader.textContent = rowIdx + 1;
                        rowHeader.className = 'row-header';
                        
                        for (let colIdx = 0; colIdx < 8; colIdx++) {
                            const td = tr.insertCell();
                            td.textContent = row[colIdx].toString().padStart(3, '0');
                            td.className = 'cube-cell';
                            td.dataset.layer = layerIdx + 1;
                            td.dataset.row = rowIdx + 1;
                            td.dataset.col = colIdx + 1;
                        }
                    }
                    
                    layerDiv.appendChild(table);
                    grid.appendChild(layerDiv);
                }
                
                roundDiv.appendChild(grid);
                container.appendChild(roundDiv);
            }

            updatePasswordStrength(password) {
                let strength = 0;
                const meter = document.getElementById('securityMeter');
                const strengthText = document.getElementById('passwordStrength');
                
                // Reset
                strengthText.querySelectorAll('span').forEach(span => span.classList.remove('active'));
                
                if (!password) {
                    meter.style.width = '0%';
                    return;
                }
                
                // Length check
                if (password.length >= 8) strength++;
                if (password.length >= 12) strength++;
                
                // Complexity checks
                if (/[A-Z]/.test(password)) strength++;
                if (/[a-z]/.test(password)) strength++;
                if (/[0-9]/.test(password)) strength++;
                if (/[^A-Za-z0-9]/.test(password)) strength++;
                
                // Normalize to 1-4 scale
                strength = Math.min(4, Math.max(1, Math.floor(strength / 1.5)));
                
                // Update meter
                meter.style.width = `${strength * 25}%`;
                
                // Update text
                strengthText.querySelector(`span[data-level="${strength}"]`).classList.add('active');
                
                // Color coding
                if (strength <= 1) {
                    meter.style.backgroundColor = this.getThemeColor('error');
                } else if (strength <= 2) {
                    meter.style.backgroundColor = this.getThemeColor('warning');
                } else {
                    meter.style.backgroundColor = this.getThemeColor('success');
                }
            }

            getThemeColor(type) {
                const style = getComputedStyle(document.documentElement);
                return style.getPropertyValue(`--${type}`);
            }

            toggleTheme() {
                const currentTheme = document.body.getAttribute('data-theme') || 'light';
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                document.body.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                this.updateThemeIcon(newTheme);
            }

            updateThemeIcon(theme) {
                const icon = document.querySelector('#themeToggle i');
                icon.className = theme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
            }

            resetToDefault() {
                document.getElementById('filler').value = '512';
                document.getElementById('encryptionKey').value = '';
                document.getElementById('rounds').value = '5';
                this.fillerByte = 512;
                this.encryptionKey = '';
                this.rounds = 5;
                this.cubes = [];
                document.getElementById('cubesContainer').innerHTML = '';
                document.getElementById('securityMeter').style.width = '0%';
                document.querySelectorAll('#passwordStrength span').forEach(span => span.classList.remove('active'));
            }

            showError(element, message) {
                element.innerHTML = `<i class="fas fa-exclamation-circle status-icon"></i> ${message}`;
                element.classList.remove('alert-success', 'alert-warning');
                element.classList.add('alert-error');
                element.style.display = 'block';
            }

            showSuccess(element, message) {
                element.innerHTML = `<i class="fas fa-check-circle status-icon"></i> ${message}`;
                element.classList.remove('alert-error', 'alert-warning');
                element.classList.add('alert-success');
                element.style.display = 'block';
            }

            switchTab(tabId) {
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add('active');
                document.getElementById(tabId).classList.add('active');
            }

            async copyToClipboard(elementId, feedbackId) {
                try {
                    const text = document.getElementById(elementId).textContent;
                    await navigator.clipboard.writeText(text);
                    
                    // Show feedback
                    const feedback = document.getElementById(feedbackId);
                    feedback.classList.add('show');
                    setTimeout(() => feedback.classList.remove('show'), 2000);
                } catch (error) {
                    console.error("Copy failed:", error);
                    alert("Failed to copy text to clipboard");
                }
            }

            saveSettingsToFile() {
                if (this.cubes.length === 0) {
                    alert("Please initialize cubes first");
                    return;
                }

                const settings = {
                    version: "2.0",
                    timestamp: new Date().toISOString(),
                    byteRange: "0-511",
                    fillerByte: this.fillerByte,
                    encryptionKey: "", // Never save the actual key
                    keyHash: this.hashString(this.encryptionKey),
                    rounds: this.rounds,
                    salt: this.salt,
                    fillMethod: this.fillMethod,
                    cubeHashes: this.cubes.map(cube => this.hashString(JSON.stringify(cube)))
                };

                const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'secure_trifid_8x8x8_settings.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            loadSettingsFromFile(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const settings = JSON.parse(e.target.result);
                        
                        // Validate settings
                        if (!settings.fillerByte || settings.fillerByte < 512 || settings.fillerByte > 999) {
                            throw new Error("Invalid filler byte in settings file");
                        }

                        if (settings.byteRange !== "0-511") {
                            throw new Error("Invalid byte range in settings file");
                        }

                        if (!settings.rounds || settings.rounds < 1 || settings.rounds > 10) {
                            throw new Error("Invalid number of rounds in settings file");
                        }

                        // Apply settings
                        document.getElementById('filler').value = settings.fillerByte;
                        document.getElementById('rounds').value = settings.rounds;
                        
                        this.fillerByte = settings.fillerByte;
                        this.rounds = settings.rounds;
                        this.salt = settings.salt || window.crypto.getRandomValues(new Uint8Array(16)).join('');
                        this.fillMethod = settings.fillMethod || "row";
                        
                        // Update previews
                        this.updateTextPreview(document.getElementById('plaintext').value, 'plaintextPreview');
                        this.updateTextPreview(document.getElementById('ciphertext').value, 'ciphertextPreview');
                        
                        // Show success
                        const statusElement = document.getElementById('alphabetStatus');
                        this.showSuccess(statusElement, "Settings loaded successfully from file");
                        
                    } catch (error) {
                        const statusElement = document.getElementById('alphabetStatus');
                        this.showError(statusElement, `Error loading settings: ${error.message}`);
                        console.error("Error loading settings:", error);
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }
        }

        // Initialize the cipher when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const cipher = new SecureTrifidCipher();
        });
    </script>
</body>
    </html>
