<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROFESSIONAL TRIFID CIPHER - DETERMINISTIC</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        body {
            background: #0a0a1a;
            color: #00ffcc;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            border-bottom: 3px solid #00ffcc;
            background: rgba(0, 20, 40, 0.8);
        }
        h1 {
            font-size: 2.5em;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #00ffcc;
        }
        .panel {
            background: rgba(0, 15, 30, 0.9);
            border: 2px solid #00ffcc;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
        }
        h2 {
            color: #ff00ff;
            margin-bottom: 20px;
            border-bottom: 2px solid #00ffcc;
            padding-bottom: 10px;
            font-size: 1.5em;
        }
        .input-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            color: #00ffcc;
            font-weight: bold;
        }
        input, textarea, select {
            width: 100%;
            padding: 12px;
            background: rgba(0, 30, 60, 0.8);
            border: 2px solid #00ffcc;
            border-radius: 6px;
            color: #00ffcc;
            font-size: 14px;
        }
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        button {
            background: linear-gradient(45deg, #ff00ff, #00ffcc);
            color: #000;
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }
        .result {
            margin-top: 20px;
            padding: 20px;
            background: rgba(0, 30, 60, 0.8);
            border: 2px solid #ff00ff;
            border-radius: 8px;
            min-height: 120px;
        }
        .hex {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            font-size: 13px;
            line-height: 1.8;
        }
        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
            background: rgba(0, 255, 0, 0.1);
            color: #00ff00;
            border: 1px solid #00ff00;
            font-weight: bold;
        }
        .error {
            background: rgba(255, 0, 0, 0.1);
            color: #ff4444;
            border-color: #ff4444;
        }
        .cube-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }
        .info-item {
            padding: 15px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00ffcc;
            border-radius: 8px;
        }
        .info-item h3 {
            color: #ff00ff;
            margin-bottom: 10px;
        }
        .key-display {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #ff00ff;
            margin-top: 10px;
            word-break: break-all;
        }
        .deterministic-test {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 40, 80, 0.8);
            border: 1px solid #ff00ff;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>PROFESSIONAL TRIFID CIPHER - DETERMINISTIC</h1>
            <div>Same Key → Same Cubes → Same Encryption</div>
        </header>

        <div class="panel">
            <h2>KEY MANAGEMENT & INITIALIZATION</h2>
            <div class="input-group">
                <label for="cryptoKey">CRYPTOGRAPHIC KEY:</label>
                <input type="password" id="cryptoKey" value="MASTER_KEY_12345">
            </div>
            
            <button onclick="initializeCipher()">INITIALIZE CIPHER</button>
            <button onclick="testDeterminism()">TEST DETERMINISM</button>
            <button onclick="verifyCubeConsistency()">VERIFY CUBE CONSISTENCY</button>
            
            <div id="keyStatus" class="status">Status: Ready for initialization</div>
            
            <div class="key-display" id="keyHashDisplay">
                Key hash: Not calculated
            </div>

            <div class="deterministic-test" id="deterministicTest">
                <strong>Deterministic Test:</strong> Same key will always produce identical cubes
            </div>
        </div>

        <div class="panel">
            <h2>DATA PROCESSING</h2>
            <div class="input-group">
                <label for="inputData">INPUT DATA:</label>
                <textarea id="inputData">48656C6C6F20576F726C64</textarea>
            </div>
            
            <div class="input-group">
                <label for="operationMode">OPERATION MODE:</label>
                <select id="operationMode">
                    <option value="encrypt">ENCRYPT</option>
                    <option value="decrypt">DECRYPT</option>
                </select>
            </div>

            <button onclick="processData()">EXECUTE</button>
            <button onclick="testRoundTrip()">TEST ROUND TRIP</button>
            
            <div class="result">
                <strong>OUTPUT:</strong>
                <div id="outputResult" class="hex"></div>
            </div>
        </div>

        <div class="cube-info">
            <div class="info-item">
                <h3>DETERMINISTIC PROPERTIES</h3>
                <p>• Fixed key → Fixed cube configuration</p>
                <p>• Repeatable encryption/decryption</p>
                <p>• Consistent coordinate mapping</p>
                <p>• Predictable transformation</p>
            </div>
            
            <div class="info-item">
                <h3>CUBE GENERATION</h3>
                <p>• 16×16×16 = 4096 elements</p>
                <p>• Key-based permutation</p>
                <p>• Deterministic shuffling</p>
                <p>• Consistent across sessions</p>
            </div>
            
            <div class="info-item">
                <h3>SECURITY</h3>
                <p>• Key-dependent cube layout</p>
                <p>• Cryptographic strength</p>
                <p>• Repeatable results</p>
                <p>• Secure transformation</p>
            </div>
        </div>
    </div>

    <script>
        class DeterministicTrifidCipher {
            constructor() {
                this.cube = null;
                this.positionMap = new Map();
                this.initialized = false;
                this.currentKeyHash = null;
            }

            initialize(keyString) {
                // Generate deterministic hash from key
                this.currentKeyHash = this.hashKey(keyString);
                
                // Initialize 16x16x16 cube structure
                this.cube = new Array(16);
                for (let k = 0; k < 16; k++) {
                    this.cube[k] = new Array(16);
                    for (let i = 0; i < 16; i++) {
                        this.cube[k][i] = new Array(16);
                    }
                }

                // Create numbers 0-4095 in order
                const numbers = Array.from({length: 4096}, (_, i) => i);
                
                // Deterministic shuffle based on key hash
                this.deterministicShuffle(numbers, this.currentKeyHash);

                // Fill cube with shuffled numbers
                let index = 0;
                for (let k = 0; k < 16; k++) {
                    for (let i = 0; i < 16; i++) {
                        for (let j = 0; j < 16; j++) {
                            const value = numbers[index++];
                            this.cube[k][i][j] = value;
                            this.positionMap.set(value, [k, i, j]);
                        }
                    }
                }

                this.initialized = true;
                return true;
            }

            hashKey(keyString) {
                // Simple deterministic hash function
                let hash = 0;
                for (let i = 0; i < keyString.length; i++) {
                    hash = ((hash << 5) - hash) + keyString.charCodeAt(i);
                    hash = hash & 0xFFFFFFFF;
                }
                return hash.toString(16).padStart(8, '0');
            }

            deterministicShuffle(array, seedHash) {
                // Convert hash to numeric seed
                let seed = parseInt(seedHash, 16);
                
                // Deterministic Fisher-Yates shuffle
                for (let i = array.length - 1; i > 0; i--) {
                    seed = (seed * 1664525 + 1013904223) & 0xFFFFFFFF;
                    const j = seed % (i + 1);
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            getCubeValue(k, x, y) {
                return this.cube[k][x][y];
            }

            getCubeSnapshot() {
                // Get first layer for verification
                const snapshot = [];
                for (let i = 0; i < 16; i++) {
                    for (let j = 0; j < 16; j++) {
                        snapshot.push(this.cube[0][i][j]);
                    }
                }
                return snapshot;
            }

            encrypt(data) {
                if (!this.initialized) throw new Error("Cipher not initialized");

                const bytes = this.parseInput(data);
                const coords = { k: [], x: [], y: [] };

                // Get coordinates for each byte
                for (const byte of bytes) {
                    const coord = this.positionMap.get(byte);
                    if (!coord) throw new Error(`Byte ${byte} not found in cube`);
                    coords.k.push(coord[0]);
                    coords.x.push(coord[1]);
                    coords.y.push(coord[2]);
                }

                // True Trifid transformation
                const allCoords = [...coords.k, ...coords.x, ...coords.y];
                const result = [];

                for (let i = 0; i < allCoords.length; i += 3) {
                    if (i + 2 < allCoords.length) {
                        const k = allCoords[i];
                        const x = allCoords[i + 1];
                        const y = allCoords[i + 2];
                        result.push(this.cube[k][x][y]);
                    }
                }

                return this.bytesToHex(new Uint8Array(result));
            }

            decrypt(hexData) {
                if (!this.initialized) throw new Error("Cipher not initialized");

                const bytes = this.hexToBytes(hexData);
                const coords = { k: [], x: [], y: [] };

                // Get coordinates for each encrypted byte
                for (const byte of bytes) {
                    const coord = this.positionMap.get(byte);
                    if (!coord) throw new Error(`Byte ${byte} not found in cube`);
                    coords.k.push(coord[0]);
                    coords.x.push(coord[1]);
                    coords.y.push(coord[2]);
                }

                // Reverse Trifid transformation
                const total = coords.k.length;
                const allCoords = [...coords.k, ...coords.x, ...coords.y];
                const result = [];

                for (let i = 0; i < total; i++) {
                    const k = allCoords[i];
                    const x = allCoords[i + total];
                    const y = allCoords[i + 2 * total];
                    result.push(this.cube[k][x][y]);
                }

                return this.bytesToHex(new Uint8Array(result));
            }

            parseInput(data) {
                if (/^[0-9A-Fa-f]+$/.test(data.replace(/\s/g, ''))) {
                    return this.hexToBytes(data);
                } else {
                    return new TextEncoder().encode(data);
                }
            }

            hexToBytes(hex) {
                const cleanHex = hex.replace(/\s/g, '');
                const bytes = [];
                for (let i = 0; i < cleanHex.length; i += 2) {
                    bytes.push(parseInt(cleanHex.substr(i, 2), 16));
                }
                return new Uint8Array(bytes);
            }

            bytesToHex(bytes) {
                return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
            }

            getKeyHash() {
                return this.currentKeyHash;
            }
        }

        const cipher = new DeterministicTrifidCipher();
        let lastCubeSnapshot = null;

        function initializeCipher() {
            const key = document.getElementById('cryptoKey').value;

            if (!key) {
                showStatus('Please enter a cryptographic key', 'error');
                return;
            }

            try {
                showStatus('Initializing deterministic cipher...', 'status');
                cipher.initialize(key);
                lastCubeSnapshot = cipher.getCubeSnapshot();
                
                showStatus('Cipher initialized successfully', 'success');
                document.getElementById('keyHashDisplay').textContent = 
                    `Key hash: ${cipher.getKeyHash()}`;
                
                document.getElementById('deterministicTest').textContent = 
                    `Deterministic Test: Key "${key}" → Cube generated (${lastCubeSnapshot.length} elements)`;

            } catch (error) {
                showStatus('Initialization failed: ' + error.message, 'error');
            }
        }

        function testDeterminism() {
            const key = document.getElementById('cryptoKey').value;
            if (!key) {
                showStatus('Please enter a key first', 'error');
                return;
            }

            // Test multiple initializations with same key
            const testCipher = new DeterministicTrifidCipher();
            testCipher.initialize(key);
            const testSnapshot = testCipher.getCubeSnapshot();

            // Compare with current cube
            const isDeterministic = JSON.stringify(lastCubeSnapshot) === JSON.stringify(testSnapshot);
            
            if (isDeterministic) {
                showStatus('✓ DETERMINISTIC: Same key produces identical cubes', 'success');
            } else {
                showStatus('✗ NON-DETERMINISTIC: Cubes differ with same key', 'error');
            }
        }

        function verifyCubeConsistency() {
            if (!cipher.initialized) {
                showStatus('Cipher not initialized', 'error');
                return;
            }

            // Verify cube consistency
            let consistent = true;
            for (let k = 0; k < 16 && consistent; k++) {
                for (let i = 0; i < 16 && consistent; i++) {
                    for (let j = 0; j < 16 && consistent; j++) {
                        const value = cipher.getCubeValue(k, i, j);
                        const [checkK, checkX, checkY] = cipher.positionMap.get(value);
                        consistent = consistent && (k === checkK && i === checkX && j === checkY);
                    }
                }
            }

            if (consistent) {
                showStatus('✓ CUBE CONSISTENCY: All values correctly mapped', 'success');
            } else {
                showStatus('✗ CUBE INCONSISTENCY: Mapping errors detected', 'error');
            }
        }

        function processData() {
            if (!cipher.initialized) {
                showStatus('Please initialize cipher first', 'error');
                return;
            }

            const input = document.getElementById('inputData').value;
            const mode = document.getElementById('operationMode').value;

            if (!input) {
                showStatus('Please enter input data', 'error');
                return;
            }

            try {
                let result;
                if (mode === 'encrypt') {
                    result = cipher.encrypt(input);
                } else {
                    result = cipher.decrypt(input);
                }
                
                document.getElementById('outputResult').textContent = result;
                showStatus('Operation completed successfully', 'success');
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        function testRoundTrip() {
            const testData = "0123456789ABCDEF";
            document.getElementById('inputData').value = testData;
            
            try {
                const encrypted = cipher.encrypt(testData);
                const decrypted = cipher.decrypt(encrypted.replace(/ /g, ''));
                
                if (decrypted.replace(/ /g, '') === testData.replace(/ /g, '')) {
                    showStatus('✓ ROUND TRIP SUCCESS: Encryption → Decryption works', 'success');
                    document.getElementById('outputResult').textContent = `Encrypted: ${encrypted} → Decrypted: ${decrypted}`;
                } else {
                    showStatus('✗ ROUND TRIP FAILED: Data corruption detected', 'error');
                }
            } catch (error) {
                showStatus('Round trip test failed: ' + error.message, 'error');
            }
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('keyStatus');
            statusEl.textContent = message;
            statusEl.className = `status ${type === 'error' ? 'error' : ''}`;
        }

        // Auto-initialize
        window.onload = initializeCipher;
    </script>
</body>
</html>
